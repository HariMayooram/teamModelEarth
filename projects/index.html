<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>List Display</title>
    <link rel="icon" type="image/x-icon" href="../img/logo/neighborhood/favicon.png">
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/shared-styles.css">
    
    <!-- Standalone Navigation -->
    <link rel="stylesheet" href="../css/standalone-nav.css">
    <script src="../js/standalone-nav.js"></script>
    
    <!-- Feather Icons -->
    <script src="https://unpkg.com/feather-icons"></script>
    <script>
        // Initialize Feather Icons
        feather.replace();
    </script>

    <style>
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Ensure all elements stay within container bounds */
        .card, .participants-table-card, .team-legend, .form-group, .input-button-group,
        .participants-table-container, .sort-dropdown, .status-dropdown {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Ensure form elements stay within bounds */
        .form-control, .form-row, .config-form {
            max-width: 100%;
            box-sizing: border-box;
        }
        
        /* Responsive table handling */
        .participants-table-container {
            overflow-x: auto;
            width: 100%;
        }
        
        .participants-table {
            width: 100%;
            min-width: 0;
        }
        
        .readme-content {
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 16px;
            background: var(--bg-tertiary);
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .form-control::placeholder {
            color: var(--text-muted);
        }
        
        .form-select {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.2s ease;
        }
        
        .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .message-log {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 12px;
            margin-top: 16px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .message-log:empty {
            display: none;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .input-button-group {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }
        
        .input-button-group .form-control {
            flex: 1;
        }
        
        @media (max-width: 500px) {
            .input-button-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-button-group .btn {
                width: 100%;
            }
        }
        
        .setup-steps {
            margin: 20px 0;
        }
        
        .step-item {
            display: flex;
            margin-bottom: 24px;
            padding: 16px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
        }
        
        .step-number {
            width: 32px;
            height: 32px;
            background: var(--accent-blue);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 16px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-content h4 {
            margin-bottom: 8px;
            color: var(--text-primary);
            font-size: 16px;
        }
        
        .step-content p {
            color: var(--text-secondary);
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .status-message {
            margin-top: 8px;
            padding: 8px 12px;
            border-radius: var(--radius-md);
            font-size: 13px;
            display: none;
        }
        
        .status-message.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-green);
            border: 1px solid rgba(16, 185, 129, 0.3);
        }
        
        .status-message.error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--accent-red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .status-message.info {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent-blue);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .config-form {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: var(--radius-md);
            margin-bottom: 24px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .config-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .form-help {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }
        
        textarea.form-control {
            resize: vertical;
            min-height: 80px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .table-container {
            overflow-x: auto;
            margin-bottom: 16px;
        }
        
        .participants-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .participants-table th,
        .participants-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-light);
        }
        
        .participants-table th {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .participants-table td {
            color: var(--text-secondary);
            max-width: 200px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            transition: all 0.2s ease;
            vertical-align: top;
        }
        
        .participants-table td.expanded {
            white-space: normal;
            word-wrap: break-word;
            max-width: none;
        }
        
        .participants-table tr:hover {
            background: rgba(59, 130, 246, 0.05);
        }
        
        .table-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .pagination-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .pagination-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
        }
        
        .pagination-btn:hover:not(:disabled) {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .pagination-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* 3-dot menu styles */
        .menu-container {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }
        
        .menu-button {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-medium);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bolder;
            transition: all 0.2s;
        }
        
        .menu-button:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .menu-button.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 180px;
            z-index: 1000;
            margin-top: 4px;
            display: none;
        }
        
        .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-light);
        }
        
        .menu-item:last-child {
            border-bottom: none;
        }
        
        .menu-item:hover {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .menu-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        /* Fullscreen styles */
        .fullscreen-mode {
            width: 100% !important;
            min-height: 100vh !important;
            z-index: 9999 !important;
            background: var(--bg-primary) !important;
            overflow-x: hidden !important;
            overflow-y: auto !important;
            padding: 0 !important;
            margin: 0 !important;
            box-sizing: border-box !important;
        }
        
        .fullscreen-mode .container {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            padding: 20px !important;
            box-sizing: border-box !important;
            overflow-x: hidden !important;
        }
        
        .fullscreen-mode .breadcrumb {
            display: none !important;
        }
        
        .fullscreen-mode .header {
            display: none !important;
        }
        
        .fullscreen-mode table {
            table-layout: fixed !important;
            width: 100% !important;
            overflow-x: auto !important;
        }
        
        .fullscreen-mode .card {
            max-width: 100% !important;
            overflow-x: hidden !important;
        }
        
        
        /* Condensed layout styles */
        .condensed-mode .view-buttons {
            display: none;
        }
        
        .condensed-mode .view-buttons-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .condensed-mode .legend-controls {
            display: none;
        }
        
        .condensed-mode .legend-controls-condensed {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-buttons-condensed {
            display: none;
        }
        
        .legend-controls-condensed {
            display: none;
        }
        
        .condensed-icon-btn {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .condensed-icon-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .condensed-icon-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            .participants-table {
                font-size: 12px;
            }
            
            .participants-table th,
            .participants-table td {
                padding: 8px 4px;
            }
            
            .table-info {
                flex-direction: column;
                gap: 8px;
            }
            
            .upload-group {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        .upload-group {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }
        
        .alternative-upload {
            border-left: 3px solid var(--accent-blue);
        }
        
        .alternative-upload h4 {
            font-size: 16px;
        }
        
        /* Snapshots Control */
        .snapshots-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-light);
        }
        
        .snapshots-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .snapshots-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .snapshots-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .snapshots-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .snapshot-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-light);
        }
        
        .snapshot-name {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid transparent;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .snapshot-name:hover {
            background: var(--bg-hover);
        }
        
        .snapshot-name.editing {
            border-color: var(--border-focus);
            background: var(--bg-primary);
            cursor: text;
        }
        
        .snapshot-save-btn {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--accent-green);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .snapshot-save-btn:hover {
            background: var(--accent-green-dark);
        }
        
        .add-snapshot {
            display: flex;
            gap: 8px;
        }
        
        .add-snapshot input {
            flex: 1;
        }
        
        /* Group Participants Control */
        .group-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .group-input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .group-input-group input {
            flex: 1;
        }
        
        #group {
            text-align: right;
            caret-color: var(--text-primary) !important;
            padding-right: 18px !important; /* Extra padding to ensure cursor visibility */
            box-sizing: border-box;
        }
        
        #group:focus {
            caret-color: var(--accent-blue) !important;
        }
        
        #group-toggle {
            white-space: nowrap;
            min-width: 100px;
        }
        
        #group-toggle.active {
            background: var(--accent-green);
            color: white;
            border-color: var(--accent-green);
        }
        
        #group-toggle-text[contenteditable="true"] {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            padding: 2px 4px;
            outline: 2px solid var(--accent-blue);
            outline-offset: 1px;
        }
        
        #group-toggle-text {
            cursor: pointer;
        }
        
        #group-toggle-text:hover {
            text-decoration: underline;
        }
        
        /* Group participant highlighting */
        .participant-group {
            border: 3px solid var(--accent-green) !important;
            box-shadow: 0 0 0 1px var(--accent-green) !important;
        }
        
        .participant-group .participant-name {
            color: var(--accent-green) !important;
            font-weight: 700 !important;
        }
        
        /* Keep gallery names white when group border is added */
        .participant-group .gallery-name {
            color: white !important;
            font-weight: 700 !important;
        }
        
        /* Table row highlighting */
        .participants-table tr.participant-group {
            background: rgba(16, 185, 129, 0.1) !important;
            border-left: 4px solid var(--accent-green) !important;
        }
        
        .participants-table tr.participant-group td:first-child {
            color: var(--accent-green) !important;
            font-weight: 600 !important;
        }
        
        /* Raw Data Control */
        .raw-data-control {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .raw-data-control textarea {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: auto;
        }
        
        /* View Controls */
        .view-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 12px;
        }
        
        .view-buttons {
            display: flex;
            gap: 8px;
        }
        
        .view-btn {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid var(--border-light);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .view-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .view-btn:hover:not(.active) {
            background: var(--border-light);
        }
        
        /* Column View (Default) - Using table-list style */
        .participants-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }
        
        .participant-card {
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
            transition: all 0.2s;
        }
        
        .participant-card:hover {
            background: var(--bg-secondary);
            box-shadow: var(--shadow-sm);
        }
        
        .participant-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 16px;
        }
        
        .participant-info {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 2px;
        }
        
        .participant-info strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .participant-projects {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 8px;
            line-height: 1.4;
            border-top: 1px solid var(--border-light);
            padding-top: 8px;
        }
        
        .participant-projects strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Gallery View */
        .participants-gallery {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }
        
        .gallery-card {
            background: linear-gradient(135deg, var(--card-bg-1), var(--card-bg-2));
            border-radius: var(--radius-lg);
            padding: 20px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .gallery-card:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-lg);
        }
        
        .gallery-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .gallery-card:hover::before {
            opacity: 1;
        }
        
        .gallery-name {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .gallery-info {
            font-size: 12px;
            opacity: 0.9;
            font-weight: 500;
        }
        
        /* Team-based color variations for gallery cards */
        .gallery-card.team-js { --card-bg-1: #667eea; --card-bg-2: #764ba2; }
        .gallery-card.team-ml { --card-bg-1: #f093fb; --card-bg-2: #f5576c; }
        .gallery-card.team-react { --card-bg-1: #4facfe; --card-bg-2: #00f2fe; }
        .gallery-card.team-io { --card-bg-1: #43e97b; --card-bg-2: #38f9d7; }
        .gallery-card.team-ai { --card-bg-1: #fa709a; --card-bg-2: #fee140; }
        .gallery-card.team-flask { --card-bg-1: #ff9a9e; --card-bg-2: #fecfef; }
        .gallery-card.team-suite { --card-bg-1: #a8edea; --card-bg-2: #fed6e3; }
        .gallery-card.team-us { --card-bg-1: #ffecd2; --card-bg-2: #fcb69f; }
        .gallery-card.team-auth { --card-bg-1: #89f7fe; --card-bg-2: #66a6ff; }
        .gallery-card.team-discord { --card-bg-1: #c2e9fb; --card-bg-2: #a1c4fd; }
        .gallery-card.team-default { --card-bg-1: #d299c2; --card-bg-2: #fef9d7; }
        
        /* Team Legend */
        .team-legend {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-light);
        }
        
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .legend-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .btn-sm {
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 4px;
        }
        
        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        .legend-item:hover {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-item.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Legend Controls */
        .legend-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
        }
        
        .button-with-dropdown {
            position: relative;
            display: inline-block;
        }
        
        /* Sort Dropdown */
        .sort-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 200px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .sort-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .sort-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .sort-items {
            padding: 8px 0;
        }
        
        .sort-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .sort-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .sort-item.active {
            background-color: var(--accent-blue);
            color: white;
        }
        
        .sort-arrow {
            font-size: 12px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
        }
        
        /* Status Dropdown */
        .status-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            min-width: 220px;
            z-index: 1000;
            margin-top: 4px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
        }
        
        .status-header h4 {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }
        
        .status-items {
            padding: 8px 0;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .status-item:hover {
            background-color: var(--bg-tertiary);
        }
        
        .status-checkbox {
            margin-right: 8px;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .status-label {
            flex: 1;
            cursor: pointer;
        }
        
        /* Responsive Design */
        @media (max-width: 1000px) {
            .participants-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 900px) {
            .container {
                padding: 0 16px;
            }
            
            .view-controls {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .config-actions {
                flex-direction: column;
                gap: 8px;
            }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0 16px;
            }
            
            .participants-grid {
                grid-template-columns: 1fr;
            }
            
            .participants-gallery {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .participants-table-container {
                overflow-x: auto;
            }
            
            .participants-table {
                min-width: 600px;
            }
            
            .table-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            
            .pagination-controls {
                align-self: flex-end;
            }
            
            .view-buttons {
                justify-content: center;
            }
            
            .legend-items {
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            .participants-gallery {
                grid-template-columns: 1fr;
            }
            
            .view-buttons {
                flex-direction: column;
            }
        }
        
        /* Loading and error states */
        .loading-state, .error-state {
            text-align: center;
            padding: 40px 20px;
            font-size: 16px;
            color: var(--text-secondary);
        }
        
        .error-state {
            color: #dc2626;
        }
        
        /* Clickable meta list items */
        .participant-card[style*="cursor: pointer"]:hover,
        .gallery-card[style*="cursor: pointer"]:hover,
        .participants-table tr[style*="cursor: pointer"]:hover {
            background-color: var(--bg-tertiary);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
            transition: all 0.2s ease;
        }
        
        .participants-table tr[style*="cursor: pointer"]:hover {
            background-color: rgba(59, 130, 246, 0.1) !important;
        }
        
        /* Raw Data Editor Close Button */
        #raw-data-close {
            transition: all 0.2s ease;
            border-radius: var(--radius-sm);
            min-width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #raw-data-close:hover {
            background-color: var(--bg-tertiary);
            border-color: var(--border-medium);
            color: var(--text-primary);
        }
        
        /* Button Groups for AI Insights */
        .insights-status {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .insight-button-group {
            display: flex;
            gap: 8px;
            align-items: center;
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 8px;
            border: 1px solid var(--border-light);
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
        }

        .insight-button-group:hover {
            box-shadow: var(--shadow-md);
            background: var(--bg-secondary);
        }

        .insight-button-group .btn {
            margin: 0;
            border-radius: 8px;
            flex: 1;
        }

        .refresh-btn {
            width: 40px;
            height: 40px;
            min-width: 40px;
            max-width: 40px;
            padding: 0;
            margin: 0;
            border-radius: 6px;
            background: var(--accent-blue);
            color: white;
            border: 1px solid var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            box-shadow: var(--shadow-sm);
            transition: all 0.2s;
            cursor: pointer;
            flex-shrink: 0;
            box-sizing: border-box;
        }

        .refresh-btn:hover {
            background: #2563EB;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .refresh-btn:active {
            transform: scale(0.95);
        }

        .refresh-btn span {
            font-size: 32px;
            line-height: 1;
            font-weight: normal;
            margin-top: -4px;
        }

        /* AI Insights Styles */
        .ai-insights {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
        }

        .insights-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .ai-icon {
            font-size: 24px;
        }

        .insights-content {
            background: var(--bg-primary);
            border-radius: var(--radius-md);
            padding: 16px;
            border: 1px solid var(--border-light);
        }

        .loading-status {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: var(--radius-md);
            text-align: left;
            font-style: italic;
            font-weight: bold;
        }

        /* Prompt Modal */
        .prompt-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .prompt-modal.hidden {
            display: none;
        }

        .prompt-modal-content {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--shadow-lg);
        }

        .prompt-modal-content h3 {
            margin-bottom: 16px;
            color: var(--text-primary);
            font-size: 20px;
            font-weight: 600;
        }

        .prompt-modal-content textarea {
            width: 100%;
            min-height: 120px;
            padding: 12px;
            border: 1px solid var(--border-light);
            border-radius: var(--radius-md);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="breadcrumb">
            <a href="../admin/">← Admin Dashboard</a>
        </div>

        <div class="header" style="display: none;">
            <h1>
                <div class="gemini-icon">G</div>
                Coding Meetup Integration
            </h1>
            <p>Filters a Google Sheet to share member details <a href="../admin/google/meetup/">during meetups</a>.
                <!--  will eventually pull a list from a Google Meetup to filter the  -->
            </p>
        </div>

        <div style="margin-bottom: 20px;">
            <div class="input-button-group" id="input-button-group" style="display: flex; align-items: center; justify-content: space-between;">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <select id="fileSelect" class="form-control" style="width: auto; min-width: 200px; max-width: calc(100% - 32px); flex: none;">
                        <option value="custom">Choose File...</option>
                    </select>
                    <button class="btn btn-primary" id="get-participants">
                        <span class="loading-spinner" id="participants-spinner" style="display: none;"></span>
                        Get List
                    </button>
                </div>
                <div class="menu-container">
                    <button class="menu-button" id="menu-toggle">
                        ⋯
                    </button>
                    <div class="menu-dropdown" id="menu-dropdown">
                        <div class="menu-item" id="fullscreen-toggle">
                            <span id="fullscreen-text">View Fullscreen</span>
                        </div>
                        <div class="menu-item" id="condensed-toggle">
                            <span id="condensed-text">Condense Layout</span>
                        </div>
                        <div class="menu-item" id="raw-data-toggle">
                            <span id="raw-data-text">View Raw Data</span>
                        </div>
                        <div class="menu-item" id="export-csv-menu">
                            <span>Export CSV</span>
                        </div>
                        <div class="menu-item" id="full-url-toggle">
                            <span>Full URL</span>
                        </div>
                        <div class="menu-item" id="snapshots-toggle">
                            <span>Snapshots</span>
                        </div>
                        <div class="menu-item" id="list-feeds-toggle">
                            <span>All Lists</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Custom file upload (hidden by default) -->
            <div class="form-group" id="customFileSection" style="display: none;">
                <div class="file-input-wrapper">
                    <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls,.csv" style="display: none;" />
                    <div class="file-input-display" id="fileDisplay" style="border: 1px solid var(--border-light); border-radius: var(--radius-md); padding: 16px; background: var(--bg-secondary); cursor: pointer; text-align: center;">
                        <div class="file-info">
                            <div class="file-name">Click to upload file</div>
                            <div class="file-details" style="color: var(--text-muted); font-size: 12px;">Supports .csv, .xls and .xlsx formats</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card" id="participants-table-card" style="display: none;">
            <div style="margin-bottom: 20px;">
                <h2 class="card-title" id="list-title" style="margin: 0;">📊 Participants List</h2>
            </div>
            
            <!-- Snapshots Control -->
            <div class="snapshots-control" id="snapshots-control" style="display: none;">
                <div class="snapshots-header">
                    <h4>Filter Snapshots</h4>
                    <button class="btn btn-sm" id="close-snapshots">×</button>
                </div>
                <div class="snapshots-content">
                    <div class="snapshots-list" id="snapshots-list">
                        <!-- Snapshots will be populated here -->
                    </div>
                    <div class="add-snapshot">
                        <input type="text" id="new-snapshot-name" class="form-control" placeholder="Enter snapshot name...">
                        <button class="btn btn-primary" id="add-snapshot-btn">Add Snapshot</button>
                    </div>
                </div>
            </div>
            
            <!-- Group Participants Control -->
            <div class="group-control" id="group-control">
                <label class="form-label">Group Participants</label>
                <div class="group-input-group">
                    <input type="text" id="group" class="form-control" placeholder="Enter names separated by commas (e.g., Loren, Ivy, Gary)...">
                    <button class="btn btn-secondary" id="group-toggle">
                        <span id="group-toggle-text">Group</span>
                        <span id="group-count">(0)</span>
                    </button>
                </div>
                <small class="form-help">Type names and press comma or enter to highlight. Click "Group" to show only marked participants.</small>
            </div>
            
            <!-- Raw Data Editor -->
            <div class="raw-data-control" id="raw-data-control" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <label class="form-label" style="margin-bottom: 0;">Raw Data Editor</label>
                    <button class="btn" id="raw-data-close" style="padding: 4px 8px; font-size: 16px; line-height: 1; background: none; border: 1px solid var(--border-light); color: var(--text-secondary);" title="Close Raw Data Editor">×</button>
                </div>
                <div class="form-group" style="margin-bottom: 12px;">
                    <label class="form-label" style="font-size: 12px; margin-bottom: 4px;">Data Source</label>
                    <input type="text" id="raw-data-source" class="form-control" readonly style="font-size: 11px; background-color: var(--bg-tertiary); color: var(--text-secondary);" placeholder="Data source path will appear here...">
                </div>
                <div class="form-group">
                    <textarea id="raw-data-editor" class="form-control" rows="10" placeholder="Raw JSON data will appear here..."></textarea>
                    <div style="margin-top: 8px;">
                        <button class="btn btn-primary" id="apply-raw-data">Display Changes</button>
                        <button class="btn btn-secondary" id="revert-raw-data">Revert</button>
                    </div>
                    <small class="form-help">Edit the JSON data and click "Display Changes" to update the participant list. Click "Revert" to restore original data.</small>
                </div>
            </div>
            
            <!-- Team Legend and Sort Controls (Shared across all views) -->
            <div class="team-legend" id="team-legend" style="display: none;">
                <div class="legend-header">
                    <h4>Filter by Team</h4>
                    <div class="legend-controls">
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm" id="sort-toggle">Sort by</button>
                            <div class="sort-dropdown" id="sort-dropdown" style="display: none;">
                                <div class="sort-header">
                                    <h4>Sort by</h4>
                                    <button class="btn btn-sm" id="close-sort">×</button>
                                </div>
                                <div class="sort-items" id="sort-items"></div>
                            </div>
                        </div>
                        <div class="button-with-dropdown">
                            <button class="btn btn-sm" id="status-toggle">Status</button>
                            <div class="status-dropdown" id="status-dropdown" style="display: none;">
                                <div class="status-header">
                                    <h4>Filter by Status</h4>
                                    <button class="btn btn-sm" id="close-status">×</button>
                                </div>
                                <div class="status-items" id="status-items"></div>
                            </div>
                        </div>
                    </div>
                    <div class="legend-controls-condensed">
                        <button class="condensed-icon-btn" id="filters-toggle" title="Filters">
                            ⚙
                        </button>
                        <div class="menu-dropdown" id="filters-dropdown" style="display: none;">
                            <div class="menu-item" id="condensed-sort-toggle">Sort by</div>
                            <div class="menu-item" id="condensed-status-toggle">Status</div>
                        </div>
                    </div>
                </div>
                <div class="legend-items" id="legend-items"></div>
            </div>
            
            <!-- View Toggle Controls -->
            <div class="view-controls">
                <div class="view-buttons">
                    <button class="btn btn-secondary view-btn active" id="column-view-btn" data-view="column">
                        Columns
                    </button>
                    <button class="btn btn-secondary view-btn" id="table-view-btn" data-view="table">
                        Table
                    </button>
                    <button class="btn btn-secondary view-btn" id="gallery-view-btn" data-view="gallery">
                        Gallery
                    </button>
                </div>
                <div class="view-buttons-condensed">
                    <button class="condensed-icon-btn" id="column-view-condensed" data-view="column" title="Columns">
                        ▦
                    </button>
                    <button class="condensed-icon-btn" id="table-view-condensed" data-view="table" title="Table">
                        ☰
                    </button>
                    <button class="condensed-icon-btn" id="gallery-view-condensed" data-view="gallery" title="Gallery">
                        ⊞
                    </button>
                </div>
                <div class="table-info">
                    <span id="results-count" style="margin-right:10px">0 results</span>
                    <div class="pagination-controls" style="display: none;">
                        <button id="prev-page" class="pagination-btn" title="Previous page">‹</button>
                        <button id="next-page" class="pagination-btn" title="Next page">›</button>
                    </div>
                </div>
            </div>
            
            
            <!-- Column View (Default) -->
            <div class="view-container" id="column-view">
                <div class="participants-grid" id="participants-column-grid"></div>
            </div>
            
            <!-- Table View -->
            <div class="view-container" id="table-view" style="display: none;">
                <div class="table-container">
                    <table id="participants-table" class="participants-table">
                        <thead id="table-header"></thead>
                        <tbody id="table-body"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Gallery View -->
            <div class="view-container" id="gallery-view" style="display: none;">
                <div class="participants-gallery" id="participants-gallery-grid"></div>
            </div>
            <!-- AI Insights -->
            <div id="aiInsights" class="ai-insights" style="display: none;">
                <div class="insights-header">
                    <div class="ai-icon">🤖</div>
                    <h3>AI-Powered Dataset Insights</h3>
                    <div class="insights-status" id="insightsStatus">
                        <div class="insight-button-group">
                            <button id="claudeInsightsBtn" class="btn btn-secondary" onclick="handleClaudeInsightsClick()">
                                <span id="claudeInsightsText">Claude Insights</span>
                            </button>
                            <button id="claudeRefreshBtn" class="btn btn-secondary refresh-btn" onclick="showRefreshPrompt('claude')" title="Refresh with custom prompt" style="display: none;">
                                <span>↻</span>
                            </button>
                        </div>
                        <div class="insight-button-group">
                            <button id="geminiInsightsBtn" class="btn btn-primary" onclick="handleGeminiInsightsClick()">
                                <span id="geminiInsightsText">Gemini Insights</span>
                            </button>
                            <button id="geminiRefreshBtn" class="btn btn-primary refresh-btn" onclick="showRefreshPrompt('gemini')" title="Refresh with custom prompt" style="display: none;">
                                <span>↻</span>
                            </button>
                            <div class="max-rows-control" style="display: flex; align-items: center; gap: 6px; margin-left: 8px; font-size: 12px;">
                                <label for="maxRowsInput" style="color: var(--text-secondary); white-space: nowrap;">Max rows:</label>
                                <input type="number" id="maxRowsInput" value="20" min="1" max="100" style="width: 50px; padding: 4px 6px; border: 1px solid var(--border-light); border-radius: 4px; font-size: 12px;" title="Maximum number of rows to send to Gemini API">
                            </div>
                        </div>
                    </div>
                </div>
                <div id="loadingStatus" class="loading-status" style="display: block; padding: 12px; margin-bottom: 16px; background: linear-gradient(135deg, #6B7280, #E5E7EB); border-radius: var(--radius-md); text-align: left; font-style: italic; color: white; font-weight: bold;">
                    Ready for AI analysis
                </div>
                <div id="insightsContent" class="insights-content">
                    <div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">
                        Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Prompt Modal for custom AI prompts -->
        <div class="prompt-modal hidden" id="promptModal">
            <div class="prompt-modal-content">
                <h3 id="promptModalTitle">Refresh AI Insights</h3>
                <div style="margin-bottom: 16px; color: var(--text-secondary); font-size: 14px;">
                    Enter a custom prompt to send with your dataset:
                </div>
                <textarea id="promptInput" placeholder="Tell me an amazing poem about this data.">Tell me an amazing poem about this data.</textarea>
                <div class="modal-actions">
                    <button class="btn btn-secondary" onclick="closePromptModal()">Cancel</button>
                    <button id="promptSubmitBtn" class="btn btn-primary" onclick="submitPrompt()">Refresh Insights</button>
                </div>
            </div>
        </div>
        
        <!-- Load Status Panel -->
        <div class="card" id="loadStatus" style="display: none;">
            <div id="participants-result"></div>
            <div id="statusMessages" class="message-log"></div>
        </div>

    </div>

    <script src="../js/common.js"></script>
    <script src="../js/list.js"></script>
    <script>
        const GEMINI_API_BASE = 'http://localhost:8081/api';
        
        // AI Insights variables
        let currentActiveAI = null;
        let currentPromptAI = null;
        const aiInsightsCache = JSON.parse(localStorage.getItem('aiInsightsCache') || '{}');
        const claudeInsightsCache = JSON.parse(localStorage.getItem('claudeInsightsCache') || '{}');
        
        // Pending analysis storage (like admin page)
        let pendingGeminiAnalysis = null;
        let pendingClaudeAnalysis = null;
        
        // AI Insights Functions
        function showAIInsightsSection() {
            const aiInsights = document.getElementById('aiInsights');
            if (aiInsights && window.participantsData && window.participantsData.length > 0) {
                aiInsights.style.display = 'block';
                showAIInsightsButtons();
            }
        }
        
        function showAIInsightsButtons() {
            const cacheKey = getCurrentDataSource();
            const hasGeminiCache = aiInsightsCache[cacheKey];
            const hasClaudeCache = claudeInsightsCache[cacheKey];
            
            // Update button states
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const claudeText = document.getElementById('claudeInsightsText');
            const claudeRefresh = document.getElementById('claudeRefreshBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            const geminiText = document.getElementById('geminiInsightsText');
            const geminiRefresh = document.getElementById('geminiRefreshBtn');
            
            if (claudeBtn && claudeText && claudeRefresh) {
                claudeBtn.disabled = false;
                claudeText.textContent = hasClaudeCache ? 'Claude Insights (Cached)' : 'Claude Insights';
                claudeRefresh.style.display = hasClaudeCache ? 'flex' : 'none';
            }
            
            if (geminiBtn && geminiText && geminiRefresh) {
                geminiBtn.disabled = false;
                geminiText.textContent = hasGeminiCache ? 'Gemini Insights (Cached)' : 'Gemini Insights';
                geminiRefresh.style.display = hasGeminiCache ? 'flex' : 'none';
            }
            
            // Show ready message
            const loadingStatus = document.getElementById('loadingStatus');
            if (loadingStatus) {
                loadingStatus.textContent = 'Ready for AI analysis';
                loadingStatus.style.display = 'block';
            }
        }
        
        function getCurrentDataSource() {
            const selectedOption = fileSelect.options[fileSelect.selectedIndex];
            if (selectedOption && selectedOption.getAttribute('data-url')) {
                return selectedOption.getAttribute('data-url');
            }
            return selectedFile || 'unknown';
        }
        
        function handleClaudeInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (claudeInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'claude');
            } else {
                showRefreshPrompt('claude');
            }
        }
        
        function handleGeminiInsightsClick() {
            if (!window.participantsData || window.participantsData.length === 0) {
                appendStatusMessage('No data available for analysis. Please load a list first.', 'error');
                return;
            }
            
            const cacheKey = getCurrentDataSource();
            if (aiInsightsCache[cacheKey]) {
                displayCachedInsights(cacheKey, 'gemini');
            } else {
                showRefreshPrompt('gemini');
            }
        }
        
        async function displayCachedInsights(cacheKey, aiType) {
            const cache = aiType === 'claude' ? claudeInsightsCache : aiInsightsCache;
            const insights = cache[cacheKey];
            
            if (insights) {
                const loadingStatus = document.getElementById('loadingStatus');
                loadingStatus.textContent = `Displaying cached ${aiType} analysis`;
                
                // Use shared display functions
                if (aiType === 'claude') {
                    await displaySharedClaudeInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                } else {
                    await displaySharedGeminiInsights(
                        insights.analysis, 
                        insights.totalRecords || 0, 
                        insights.sampleSize || 0, 
                        false, 
                        insights.customPrompt || insights.prompt || 'Standard data analysis prompt'
                    );
                }
                
                // Update button states
                currentActiveAI = aiType;
                updateActiveAIButtons();
            }
        }
        
        function showRefreshPrompt(aiType) {
            currentPromptAI = aiType;
            const modal = document.getElementById('promptModal');
            const title = document.getElementById('promptModalTitle');
            
            title.textContent = `${aiType === 'claude' ? 'Claude' : 'Gemini'} Analysis`;
            modal.classList.remove('hidden');
        }
        
        function closePromptModal() {
            const modal = document.getElementById('promptModal');
            modal.classList.add('hidden');
            currentPromptAI = null;
        }
        
        // Function to get currently filtered and sorted data for AI analysis
        function getCurrentlyDisplayedData() {
            // Start with the sorted data (allParticipantsData has sort order applied)
            if (!allParticipantsData || allParticipantsData.length === 0) {
                console.warn('⚠️ getCurrentlyDisplayedData called but allParticipantsData is empty');
                return [];
            }
            
            let filteredData = [...allParticipantsData];
            
            // Apply status filter (same logic as in applyAllFilters)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    return selectedStatuses.has(status);
                });
            }
            
            // Apply team filter if active
            if (currentTeamFilter) {
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    return participantTeamClasses.includes(currentTeamFilter);
                });
            }
            
            // Apply group participants filter if active
            if (showOnlyGroup) {
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
            }
            
            return filteredData;
        }

        async function submitPrompt() {
            const prompt = document.getElementById('promptInput').value;
            const aiType = currentPromptAI;
            
            if (!prompt || !aiType || !window.participantsData) return;
            
            closePromptModal();
            
            // Show loading state
            const loadingStatus = document.getElementById('loadingStatus');
            const content = document.getElementById('insightsContent');
            
            loadingStatus.textContent = `Analyzing data with ${aiType}...`;
            content.innerHTML = '<div style="padding: 20px; text-align: center;">🔄 Generating insights...</div>';
            
            try {
                // Get currently filtered and sorted data instead of raw data
                const currentlyDisplayedData = getCurrentlyDisplayedData();
                const maxRows = parseInt(document.getElementById('maxRowsInput')?.value || 20);
                const analysisData = currentlyDisplayedData.slice(0, maxRows);
                
                // Get all available headers from the original data to include complete row information
                const allHeaders = window.participantsData.length > 0 ? Object.keys(window.participantsData[0]) : [];
                
                console.log(`📊 AI Analysis Data Summary:
- Original dataset: ${window.participantsData.length} records
- After filters: ${currentlyDisplayedData.length} records  
- Sent for analysis: ${analysisData.length} records
- All available columns: ${allHeaders.length} (${allHeaders.join(', ')})
- Current sort: ${currentSortColumn || 'none'} ${currentSortOrder || ''}`);
                
                // Ensure analysis data includes all columns, not just visible ones
                const completeAnalysisData = analysisData.map(row => {
                    const completeRow = {};
                    allHeaders.forEach(header => {
                        completeRow[header] = row[header] || null;
                    });
                    return completeRow;
                });
                
                const endpoint = aiType === 'claude' ? '/claude/analyze' : '/gemini/analyze';
                const response = await fetch(`${GEMINI_API_BASE}${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(aiType === 'claude' ? {
                        prompt: prompt,
                        dataset_info: {
                            record_count: window.participantsData.length,
                            filtered_count: currentlyDisplayedData.length,
                            sample_data: completeAnalysisData,
                            headers: allHeaders,
                            sort_info: {
                                column: currentSortColumn || null,
                                order: currentSortOrder || null
                            },
                            filter_info: {
                                status_filter: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                                team_filter: currentTeamFilter || null,
                                group_filter: showOnlyGroup || false
                            }
                        }
                    } : {
                        // For Gemini, include dataset directly in prompt with filter/sort context
                        prompt: `${prompt}

**Dataset Context:**
-- Original Total Records: ${window.participantsData.length}
-- After Filters Applied: ${currentlyDisplayedData.length}
-- Sample Size for Analysis: ${completeAnalysisData.length}
-- All Available Headers: ${allHeaders.join(', ')}
-- Current Sort Order: ${currentSortColumn ? `${currentSortColumn} (${currentSortOrder})` : 'Default order'}
-- Active Filters: ${(() => {
    const filters = [];
    if (selectedStatuses.size > 0 && !selectedStatuses.has('All')) {
        filters.push(`Status: ${Array.from(selectedStatuses).join(', ')}`);
    }
    if (currentTeamFilter) {
        filters.push(`Team: ${currentTeamFilter}`);
    }
    if (showOnlyGroup) {
        filters.push('Group participants only');
    }
    return filters.length > 0 ? filters.join('; ') : 'None';
})()}

**Sample Data (JSON format - filtered/sorted as displayed):**
${JSON.stringify(completeAnalysisData, null, 2)}`,
                        data_context: null
                    })
                });
                
                const result = await response.json();
                
                if (result.success && result.analysis) {
                    // Append token usage information if available
                    let analysisWithTokens = result.analysis;
                    if (result.token_usage) {
                        analysisWithTokens = appendTokenUsage(result.analysis, result.token_usage);
                    }
                    
                    // Store in pending analysis (don't save to cache yet - user needs to save)
                    const pendingData = {
                        success: true,
                        analysis: analysisWithTokens,
                        totalRecords: window.participantsData.length,
                        filteredRecords: currentlyDisplayedData.length,
                        sampleSize: completeAnalysisData.length,
                        timestamp: new Date().toISOString(),
                        customPrompt: prompt,
                        sortInfo: {
                            column: currentSortColumn || null,
                            order: currentSortOrder || null
                        },
                        filterInfo: {
                            status: selectedStatuses.size > 0 && !selectedStatuses.has('All') ? Array.from(selectedStatuses) : null,
                            team: currentTeamFilter || null,
                            groupOnly: showOnlyGroup || false
                        }
                    };
                    
                    if (aiType === 'claude') {
                        pendingClaudeAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedClaudeInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        loadingStatus.textContent = '✅ Claude analysis complete! Choose Save to keep or Cancel to revert.';
                    } else {
                        pendingGeminiAnalysis = pendingData;
                        // Display with Save/Cancel buttons - show filtered count in UI
                        await displaySharedGeminiInsights(analysisWithTokens, currentlyDisplayedData.length, completeAnalysisData.length, true, prompt);
                        loadingStatus.textContent = '✅ Gemini analysis complete! Choose Save to keep or Cancel to revert.';
                    }
                    
                    showAIInsightsButtons(); // Update button states
                    
                } else {
                    content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${result.error || 'Unknown error'}</div>`;
                    loadingStatus.textContent = 'Analysis failed';
                }
                
            } catch (error) {
                console.error('AI analysis error:', error);
                content.innerHTML = `<div style="padding: 16px; color: var(--error-color);">Analysis failed: ${error.message}</div>`;
                loadingStatus.textContent = 'Analysis failed';
            }
        }
        
        function updateActiveAIButtons() {
            // Update button states based on active AI
            const claudeBtn = document.getElementById('claudeInsightsBtn');
            const geminiBtn = document.getElementById('geminiInsightsBtn');
            
            if (claudeBtn && geminiBtn) {
                claudeBtn.classList.toggle('active', currentActiveAI === 'claude');
                geminiBtn.classList.toggle('active', currentActiveAI === 'gemini');
            }
        }
        
        // Save/Cancel functions for Claude analysis (required by shared functions)
        function saveClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Claude analysis to cache with key:', cacheKey);
                
                const loadingStatus = document.getElementById('loadingStatus');
                loadingStatus.textContent = '💾 Saving Claude analysis to cache...';
                
                // Save to cache
                claudeInsightsCache[cacheKey] = pendingClaudeAnalysis;
                localStorage.setItem('claudeInsightsCache', JSON.stringify(claudeInsightsCache));
                
                // Clear pending analysis
                pendingClaudeAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedClaudeInsights(
                    claudeInsightsCache[cacheKey].analysis, 
                    claudeInsightsCache[cacheKey].totalRecords, 
                    claudeInsightsCache[cacheKey].sampleSize, 
                    false,
                    claudeInsightsCache[cacheKey].customPrompt
                );
                
                loadingStatus.textContent = 'Claude analysis saved successfully';
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelClaudeAnalysis() {
            if (pendingClaudeAnalysis) {
                pendingClaudeAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (claudeInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'claude');
                } else {
                    const content = document.getElementById('insightsContent');
                    const loadingStatus = document.getElementById('loadingStatus');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.</div>';
                    loadingStatus.textContent = 'New analysis canceled. No previous analysis found.';
                }
            }
        }
        
        // Save/Cancel functions for Gemini analysis (required by shared functions)
        function saveGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                const cacheKey = getCurrentDataSource();
                console.log('Saving Gemini analysis to cache with key:', cacheKey);
                
                const loadingStatus = document.getElementById('loadingStatus');
                loadingStatus.textContent = '💾 Saving Gemini analysis to cache...';
                
                // Save to cache
                aiInsightsCache[cacheKey] = pendingGeminiAnalysis;
                localStorage.setItem('aiInsightsCache', JSON.stringify(aiInsightsCache));
                
                // Clear pending analysis
                pendingGeminiAnalysis = null;
                
                // Re-display without Save/Cancel buttons
                displaySharedGeminiInsights(
                    aiInsightsCache[cacheKey].analysis, 
                    aiInsightsCache[cacheKey].totalRecords, 
                    aiInsightsCache[cacheKey].sampleSize, 
                    false,
                    aiInsightsCache[cacheKey].customPrompt
                );
                
                loadingStatus.textContent = 'Gemini analysis saved successfully';
                showAIInsightsButtons(); // Update button states
            }
        }
        
        function cancelGeminiAnalysis() {
            if (pendingGeminiAnalysis) {
                pendingGeminiAnalysis = null;
                const cacheKey = getCurrentDataSource();
                
                // Check if there's a cached version to restore
                if (aiInsightsCache[cacheKey]) {
                    displayCachedInsights(cacheKey, 'gemini');
                } else {
                    const content = document.getElementById('insightsContent');
                    const loadingStatus = document.getElementById('loadingStatus');
                    content.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; text-align: center; padding: 20px;">Click "Claude Insights" or "Gemini Insights" for AI analysis. Use the ↻ refresh button for custom prompts.</div>';
                    loadingStatus.textContent = 'New analysis canceled. No previous analysis found.';
                }
            }
        }

        // Google Meetup Participants
        const getParticipantsButton = document.getElementById('get-participants');
        const participantsSpinner = document.getElementById('participants-spinner');
        const participantsResult = document.getElementById('participants-result');
        const fileSelect = document.getElementById('fileSelect');
        const customFileSection = document.getElementById('customFileSection');
        const fileInput = document.getElementById('excelFile');
        const fileDisplay = document.getElementById('fileDisplay');
        const statusMessages = document.getElementById('statusMessages');
        
        let selectedFile = null;
        let customFiles = {};

        // Helper function to append messages to statusMessages
        function appendStatusMessage(message, type = 'info') {
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.innerHTML = message;
            statusMessages.appendChild(messageDiv);
        }

        // Helper function to get modelteam URL from dropdown options
        function getModelteamUrl() {
            const modelteamOption = Array.from(fileSelect.options).find(option => option.value === 'modelteam');
            return modelteamOption ? modelteamOption.getAttribute('data-url') : null;
        }
        
        async function getMeetupParticipants() {
            // Get URL from selected dropdown option
            const selectedOption = fileSelect.options[fileSelect.selectedIndex];
            let meetupLink = selectedOption.getAttribute('data-url') || selectedFile;
            const isCors = selectedOption.getAttribute('data-cors') === 'true';
            
            // If no valid URL found, try to get modelteam URL from dropdown
            if (!meetupLink) {
                meetupLink = getModelteamUrl();
                if (!meetupLink) {
                    appendStatusMessage('Please select a valid data source or wait for options to load.', 'error');
                    return;
                }
            }

            try {
                getParticipantsButton.disabled = true;
                participantsSpinner.style.display = 'inline-block';
                
                // Hide table initially
                document.getElementById('participants-table-card').style.display = 'none';

                // Use unified data loading from js/list.js
                console.log(`Loading data from: ${meetupLink}, CORS: ${isCors}`);
                const loadResult = await loadUnifiedData(meetupLink, {
                    forceCorsProxy: isCors,
                    API_BASE: GEMINI_API_BASE
                });
                
                if (!loadResult.data || loadResult.data.length === 0) {
                    const errorMessage = `No data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Data Found</h4><p>${errorMessage}</p>`, 'error');
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Filter out any null/undefined rows
                const validData = loadResult.data.filter(row => row && typeof row === 'object');
                
                if (validData.length === 0) {
                    const errorMessage = `No valid data found in the source\n\nPath attempted: ${meetupLink}`;
                    
                    // Show error in status messages
                    appendStatusMessage(`<h4>No Valid Data Found</h4><p>${errorMessage}</p>`, 'error');
                    document.getElementById('loadStatus').style.display = 'block';
                    
                    // Populate Raw Data Editor with the load result
                    const rawDataEditor = document.getElementById('raw-data-editor');
                    const rawDataSource = document.getElementById('raw-data-source');
                    
                    if (rawDataEditor) {
                        rawDataEditor.value = JSON.stringify(loadResult, null, 2);
                    }
                    
                    if (rawDataSource) {
                        rawDataSource.value = meetupLink;
                    }
                    
                    // Show Raw Data Editor panel
                    const rawDataControl = document.getElementById('raw-data-control');
                    if (rawDataControl) {
                        rawDataControl.style.display = 'block';
                        
                        // Update toggle text
                        const rawDataText = document.getElementById('raw-data-text');
                        if (rawDataText) {
                            rawDataText.textContent = 'Hide Raw Data';
                        }
                        
                        // Set rawDataVisible flag
                        if (typeof rawDataVisible !== 'undefined') {
                            rawDataVisible = true;
                        }
                    }
                    
                    // Show the table card so the 3-dot menu remains accessible
                    document.getElementById('participants-table-card').style.display = 'block';
                    
                    // Show upload fallback
                    const uploadFallback = document.getElementById('upload-fallback');
                    if (uploadFallback) {
                        uploadFallback.style.display = 'block';
                    }
                    
                    return; // Exit the function instead of throwing
                }
                
                // Reset team legend flag for new data
                initialTeamLegendGenerated = false;
                
                // Always populate Raw Data Editor when data is successfully fetched
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor) {
                    // Use the raw data before preprocessing
                    originalRawData = JSON.parse(JSON.stringify(loadResult.data));
                    rawDataEditor.value = JSON.stringify(loadResult.data, null, 2);
                }
                
                if (rawDataSource) {
                    rawDataSource.value = meetupLink;
                }
                
                displayParticipantsTable(validData);
                
                appendStatusMessage(`Successfully loaded ${validData.length} records from ${loadResult.format.toUpperCase()} source`, 'success');
                document.getElementById('loadStatus').style.display = 'block';
                
                // Show UI elements after successful data load
                showListDisplayElements();
                
                // Show AI Insights section after successful data load
                showAIInsightsSection();

            } catch (error) {
                console.error('Full error details:', error);
                
                // Always populate Raw Data Editor with error response for debugging
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && error.rawResponse) {
                    // Show the raw error response from the API
                    originalRawData = JSON.parse(JSON.stringify(error.rawResponse));
                    rawDataEditor.value = JSON.stringify(error.rawResponse, null, 2);
                    console.log('Populated Raw Data Editor with error response:', error.rawResponse);
                }
                
                if (rawDataSource && error.requestUrl) {
                    rawDataSource.value = error.requestUrl;
                }
                
                appendStatusMessage(`<h4>Error Loading Data</h4><p>${error.message}</p>`, 'error');
                document.getElementById('loadStatus').style.display = 'block';
                
                // Show the table card so the 3-dot menu remains accessible
                document.getElementById('participants-table-card').style.display = 'block';
                
                // Log error for debugging
                console.log('Showing upload fallback due to error:', error.message);
            } finally {
                getParticipantsButton.disabled = false;
                participantsSpinner.style.display = 'none';
            }
        }

        // Note: parseCSV function is now available from js/list.js
        
        // Helper function to get list-specific localStorage key
        function getListStorageKey(baseKey) {
            const listId = getURLHashParam('list') || 'default';
            return `${listId}_1_${baseKey}`;
        }
        
        // Current view mode and filtering
        let currentView = getURLHashParam('display') || 'column'; // Always default to column if absent from hash
        let currentTeamFilter = getURLHashParam('team') || localStorage.getItem(getListStorageKey('participantsTeamFilter')) || null;
        let initialTeamLegendGenerated = false;
        
        // Flag to prevent group parameter processing during status updates
        let isUpdatingStatus = false;
        
        // File selection state
        const STORAGE_KEY = 'listObject';
        let allParticipantsData = [];
        let groupParticipants = new Set();
        
        // Layout state
        let isFullscreen = JSON.parse(localStorage.getItem('isFullscreen') || 'false');
        let isCondensed = JSON.parse(localStorage.getItem('isCondensed') || 'false');
        
        // Sort functionality - only use localStorage (not in URL hash anymore)
        let currentSortColumn = localStorage.getItem(getListStorageKey('participantsSortColumn')) || 'Rows';
        let currentSortOrder = localStorage.getItem(getListStorageKey('participantsSortOrder')) || 'asc';
        
        // Pagination functionality
        let currentPage = 1;
        const recordsPerPage = 500;
        let totalRecords = 0;
        let originalDataOrder = [];
        
        // Status filtering - check URL hash first, then localStorage
        let selectedStatuses = new Set(getURLHashParam('status') ? getURLHashParam('status').split(',') : JSON.parse(localStorage.getItem(getListStorageKey('participantsStatusFilter')) || '["All"]'));
        let availableStatuses = [];
        
        // Group participants toggle state
        let showOnlyGroup = JSON.parse(localStorage.getItem(getListStorageKey('showOnlyGroup')) || 'false');
        
        // Team color mapping
        const teamColors = {
            'js': { class: 'team-js', color: '#667eea', name: 'JS' },
            'ml': { class: 'team-ml', color: '#f093fb', name: 'ML' },
            'react': { class: 'team-react', color: '#4facfe', name: 'React' },
            'io': { class: 'team-io', color: '#43e97b', name: 'IO' },
            'ai': { class: 'team-ai', color: '#fa709a', name: 'AI' },
            'flask': { class: 'team-flask', color: '#ff9a9e', name: 'Flask' },
            'suite': { class: 'team-suite', color: '#a8edea', name: 'Suite' },
            'us': { class: 'team-us', color: '#ffecd2', name: 'US' },
            'auth': { class: 'team-auth', color: '#89f7fe', name: 'Auth' },
            'discord': { class: 'team-discord', color: '#c2e9fb', name: 'Discord' },
            'modelteam': { class: 'team-modelteam', color: '#10B981', name: 'Model Team' },
            'default': { class: 'team-default', color: '#d299c2', name: 'Other' }
        };
        
        // Display participants in all views
        function displayParticipantsTable(data) {
            console.log('displayParticipantsTable called with data:', data);
            if (!data || data.length === 0) {
                console.log('displayParticipantsTable: No data provided, returning early');
                return;
            }
            
            // Preprocess data to clean column names and normalize structure
            console.log('displayParticipantsTable: Preprocessing data...');
            const preprocessedData = preprocessParticipantData(data);
            console.log('displayParticipantsTable: Preprocessed data:', preprocessedData);
            
            const tableCard = document.getElementById('participants-table-card');
            const resultsCount = document.getElementById('results-count');
            
            // Reset to first page when new data loads
            currentPage = 1;
            
            // Update results count with pagination
            updateResultsCount(preprocessedData);
            
            // Store preprocessed data globally
            window.participantsData = preprocessedData;
            allParticipantsData = preprocessedData;
            originalDataOrder = [...preprocessedData]; // Store original order
            
            // Update Raw Data Editor with preprocessed data if it's currently visible
            if (rawDataVisible) {
                const rawDataEditor = document.getElementById('raw-data-editor');
                const rawDataSource = document.getElementById('raw-data-source');
                
                if (rawDataEditor && rawDataEditor.value) {
                    // Only update if the Raw Data Editor doesn't already have raw data
                    // (the raw data was already populated in getMeetupParticipants)
                    console.log('Raw Data Editor already populated with raw data, skipping preprocessed update');
                } else if (rawDataEditor) {
                    // Fallback: populate with preprocessed data if raw data wasn't available
                    originalRawData = JSON.parse(JSON.stringify(preprocessedData));
                    rawDataEditor.value = JSON.stringify(preprocessedData, null, 2);
                    
                    if (rawDataSource) {
                        rawDataSource.value = getCurrentDataSource();
                    }
                }
            }
            
            // Generate team legend only once from the initial full dataset
            if (!initialTeamLegendGenerated) {
                generateTeamLegend(preprocessedData);
                initialTeamLegendGenerated = true;
            }
            
            // Load group participants from storage and apply highlighting
            loadGroupParticipants();
            updateGroupHighlighting();
            
            // Re-validate group names now that data is available
            if (groupParticipants.size > 0) {
                validateGroupNames(Array.from(groupParticipants));
            }
            
            // Update group participants panel visibility
            updateGroupParticipantsVisibility();
            
            // Render will be handled by applyAllFilters after setTimeout
            
            // Apply saved sort preferences (without re-rendering, setTimeout will handle rendering)
            if (currentSortColumn) {
                applySortToData(false);
            }
            
            // Update status button text
            updateStatusButtonText();
            
            // Restore group toggle UI state
            updateGroupToggleUI();
            
            // Apply all saved filters (team + status + group)
            console.log('displayParticipantsTable: Scheduling applyAllFilters with setTimeout...');
            setTimeout(() => {
                console.log('displayParticipantsTable: setTimeout callback executing, calling applyAllFilters...');
                applyAllFilters();
            }, 100);
            
            // Show the card and initialize view
            tableCard.style.display = 'block';
            switchView(currentView);
        }
        
        // Render column view (default) - Using table-list style
        function renderColumnView(data) {
            const container = document.getElementById('participants-column-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderColumnView');
                return;
            }
            
            const isMetaList = getURLHashParam('list') === 'all';
            
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                const card = document.createElement('div');
                card.className = 'participant-card';
                
                const name = getParticipantName(participant);
                card.dataset.participantName = name;
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.Feed) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.Feed}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.Feed);
                        updateParticipantListTitle(participant.Title || participant.Feed);
                    });
                }
                const team = participant.Team || 'Not specified';
                const projects = participant.Projects || 'No projects listed';
                const status = participant.Status || 'Unknown';
                const location = participant.Location || 'Location not specified';
                
                card.innerHTML = `
                    <div class="participant-name">${name}</div>
                    <div class="participant-info"><strong>Team:</strong> ${team}</div>
                    <div class="participant-info"><strong>Status:</strong> <span class="participant-status ${status.toLowerCase()}">${status}</span></div>
                    <div class="participant-info"><strong>Location:</strong> ${location}</div>
                    <div class="participant-projects"><strong>Projects:</strong> ${projects}</div>
                `;
                
                container.appendChild(card);
            });
        }
        
        // Render table view
        function renderTableView(data) {
            const tableHeader = document.getElementById('table-header');
            const tableBody = document.getElementById('table-body');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderTableView');
                return;
            }
            
            // Get headers from first row
            const headers = Object.keys(data[0] || {});
            
            // Create table header
            tableHeader.innerHTML = '';
            const headerRow = document.createElement('tr');
            headers.forEach(header => {
                const th = document.createElement('th');
                th.style.cursor = 'pointer';
                th.style.userSelect = 'none';
                th.style.position = 'relative';
                
                // Add click handler for sorting
                th.addEventListener('click', () => sortBy(header));
                
                // Add header text and sort arrow
                const headerText = document.createElement('span');
                headerText.textContent = header;
                th.appendChild(headerText);
                
                // Add sort arrow if this is the current sort column
                if (currentSortColumn === header) {
                    const arrow = document.createElement('span');
                    arrow.innerHTML = currentSortOrder === 'asc' ? ' ↑' : ' ↓';
                    arrow.style.marginLeft = '4px';
                    arrow.style.fontSize = '12px';
                    th.appendChild(arrow);
                }
                
                headerRow.appendChild(th);
            });
            tableHeader.appendChild(headerRow);
            
            // Create table body
            tableBody.innerHTML = '';
            const isMetaList = getURLHashParam('list') === 'all';
            
            data.forEach(row => {
                if (!row) return; // Skip null/undefined rows
                const tr = document.createElement('tr');
                tr.dataset.participantName = getParticipantName(row);
                
                // Add row-level click handling variables
                let mouseDownTime = 0;
                let mouseDownPos = { x: 0, y: 0 };
                let savedSelectionOnMouseDown = null;
                
                // Track mouse down on the row to detect selection attempts and capture selection
                tr.addEventListener('mousedown', (e) => {
                    mouseDownTime = Date.now();
                    mouseDownPos = { x: e.clientX, y: e.clientY };
                    
                    // Capture any existing selection immediately on mousedown
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0 && selection.toString().length > 0) {
                        savedSelectionOnMouseDown = selection.getRangeAt(0).cloneRange();
                    } else {
                        savedSelectionOnMouseDown = null;
                    }
                });
                
                // Add row-level click event to toggle expanded state
                tr.addEventListener('click', (e) => {
                    // Handle meta list navigation first
                    if (isMetaList && row.Feed) {
                        const clickTime = Date.now();
                        const timeDiff = clickTime - mouseDownTime;
                        const distance = Math.sqrt(
                            Math.pow(e.clientX - mouseDownPos.x, 2) + 
                            Math.pow(e.clientY - mouseDownPos.y, 2)
                        );
                        
                        // Only navigate if it's a quick click (not text selection)
                        if (timeDiff <= 200 && distance <= 5) {
                            setURLHashParam('list', row.Feed);
                            updateParticipantListTitle(row.Title || row.Feed);
                            return;
                        }
                    }
                    
                    const clickTime = Date.now();
                    const timeDiff = clickTime - mouseDownTime;
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - mouseDownPos.x, 2) + 
                        Math.pow(e.clientY - mouseDownPos.y, 2)
                    );
                    
                    // Don't toggle if this appears to be the end of a text selection
                    // (long press or mouse movement suggests selection intent)
                    if (timeDiff > 200 || distance > 5) {
                        return;
                    }
                    
                    // Toggle expanded class for all cells in this row
                    const allCellsInRow = tr.querySelectorAll('td');
                    allCellsInRow.forEach(cell => {
                        cell.classList.toggle('expanded');
                    });
                    
                    // Restore selection that was captured on mousedown
                    if (savedSelectionOnMouseDown) {
                        const selection = window.getSelection();
                        setTimeout(() => {
                            selection.removeAllRanges();
                            selection.addRange(savedSelectionOnMouseDown);
                        }, 0);
                    }
                });
                
                // Add clickable functionality for meta list
                if (isMetaList && row.Feed) {
                    tr.style.cursor = 'pointer';
                    tr.title = `Click to view data from: ${row.Title || row.Feed}`;
                }
                
                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = row[header] || '';
                    tr.appendChild(td);
                });
                tableBody.appendChild(tr);
            });
        }
        
        // Get team class based on team value (checks all teams in comma-separated list)
        function getTeamClass(teamString) {
            if (!teamString) return 'team-default';
            
            // Split by comma and check each team
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            
            // Check for team keywords in order of priority
            for (const team of teams) {
                if (team.includes('js')) return 'team-js';
                if (team.includes('ml')) return 'team-ml';
                if (team.includes('react')) return 'team-react';
                if (team.includes('io')) return 'team-io';
                if (team.includes('ai')) return 'team-ai';
                if (team.includes('flask')) return 'team-flask';
                if (team.includes('suite')) return 'team-suite';
                if (team.includes('us')) return 'team-us';
                if (team.includes('auth')) return 'team-auth';
                if (team.includes('discord')) return 'team-discord';
            }
            
            return 'team-default';
        }
        
        // Get all matching team classes for a participant (for filtering)
        function getAllTeamClasses(teamString) {
            console.log('getAllTeamClasses called with:', teamString);
            if (!teamString) {
                console.log('No team string provided, using default');
                return ['team-default'];
            }
            
            const matchingTeams = [];
            const teams = teamString.split(',').map(team => team.trim().toLowerCase());
            console.log('Teams after processing:', teams);
            
            // Check each team and collect all matches
            for (const team of teams) {
                if (team.includes('js')) matchingTeams.push('team-js');
                else if (team.includes('ml')) matchingTeams.push('team-ml');
                else if (team.includes('react')) matchingTeams.push('team-react');
                else if (team.includes('io')) matchingTeams.push('team-io');
                else if (team.includes('ai')) matchingTeams.push('team-ai');
                else if (team.includes('flask')) matchingTeams.push('team-flask');
                else if (team.includes('suite')) matchingTeams.push('team-suite');
                else if (team.includes('us')) matchingTeams.push('team-us');
                else if (team.includes('auth')) matchingTeams.push('team-auth');
                else if (team.includes('discord')) matchingTeams.push('team-discord');
            }
            
            const result = matchingTeams.length > 0 ? matchingTeams : ['team-default'];
            console.log('Team detection result:', result);
            return result;
        }
        
        // Generate team legend
        function generateTeamLegend(data) {
            console.log('generateTeamLegend called with data:', data.length, 'items');
            const teamLegend = document.getElementById('team-legend');
            const legendItems = document.getElementById('legend-items');
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.log('No data provided, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Check if Team column exists in the data
            const hasTeamColumn = data.length > 0 && data[0].hasOwnProperty('Team');
            if (!hasTeamColumn) {
                console.log('No Team column found in data, hiding team legend');
                teamLegend.style.display = 'none';
                return;
            }
            
            // Get unique teams from data (collect all team classes for each participant)
            const teams = new Set();
            data.forEach((participant, index) => {
                if (!participant) return; // Skip null/undefined participants
                console.log(`Participant ${index} - Team field:`, participant.Team);
                const teamClasses = getAllTeamClasses(participant.Team);
                teamClasses.forEach(teamClass => teams.add(teamClass));
            });
            
            console.log('Unique teams found:', Array.from(teams));
            
            // Create legend items
            legendItems.innerHTML = '';
            
            // Add "Show All" button as first item (active by default)
            const showAllItem = document.createElement('div');
            showAllItem.className = 'legend-item active';
            showAllItem.id = 'clear-team-filter';
            showAllItem.innerHTML = `
                <div class="legend-color" style="background: #ddd;"></div>
                <span>Show All</span>
            `;
            showAllItem.addEventListener('click', clearTeamFilter);
            legendItems.appendChild(showAllItem);
            
            // Add team filter buttons
            console.log('Creating team filter buttons for teams:', Array.from(teams));
            teams.forEach(teamClass => {
                const teamInfo = Object.values(teamColors).find(t => t.class === teamClass) || teamColors.default;
                console.log(`Creating filter for team: ${teamClass}, info:`, teamInfo);
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.dataset.team = teamClass;
                legendItem.innerHTML = `
                    <div class="legend-color" style="background: ${teamInfo.color};"></div>
                    <span>${teamInfo.name}</span>
                `;
                
                legendItem.addEventListener('click', () => filterByTeam(teamClass));
                legendItems.appendChild(legendItem);
                console.log('Added team filter button:', teamInfo.name);
            });
            
            // Always show team legend if teams are detected (even if only one team)
            teamLegend.style.display = teams.size > 0 ? 'block' : 'none';
            
            // Restore team filter highlighting from storage
            restoreTeamFilterHighlighting();
        }
        
        // Restore team filter highlighting when recalled from browser storage
        function restoreTeamFilterHighlighting() {
            if (currentTeamFilter) {
                console.log('Restoring team filter highlighting for:', currentTeamFilter);
                
                // Clear all active states first
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Find and highlight the matching team legend item
                const matchingItem = document.querySelector(`.legend-item[data-team="${currentTeamFilter}"]`);
                if (matchingItem) {
                    matchingItem.classList.add('active');
                    console.log('Team filter highlighting restored for:', currentTeamFilter);
                } else {
                    console.log('No matching legend item found for team filter:', currentTeamFilter);
                }
            } else {
                // No team filter active, highlight "Show All"
                document.querySelectorAll('.legend-item').forEach(item => {
                    item.classList.remove('active');
                });
                const showAllItem = document.getElementById('clear-team-filter');
                if (showAllItem) {
                    showAllItem.classList.add('active');
                }
            }
        }
        
        // Filter by team
        function filterByTeam(teamClass) {
            // If clicking on the already selected team, clear the filter
            if (currentTeamFilter === teamClass) {
                clearTeamFilter();
                return;
            }
            
            currentTeamFilter = teamClass;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Save team filter preference to localStorage
            localStorage.setItem(getListStorageKey('participantsTeamFilter'), teamClass);
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.toggle('active', item.dataset.team === teamClass);
            });
            
            // Remove active state from "Show All" button
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.remove('active');
            }
            
            // Apply all filters (team + status)
            applyAllFilters();
        }
        
        // Clear team filter
        function clearTeamFilter() {
            currentTeamFilter = null;
            
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Remove team filter preference from localStorage
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Update legend active state
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Make "Show All" button active
            const showAllButton = document.getElementById('clear-team-filter');
            if (showAllButton) {
                showAllButton.classList.add('active');
            }
            
            // Apply all filters (status only now)
            applyAllFilters();
        }
        
        // Render gallery view
        function renderGalleryView(data) {
            renderGalleryCards(data);
        }
        
        // Render gallery cards
        function renderGalleryCards(data) {
            const container = document.getElementById('participants-gallery-grid');
            container.innerHTML = '';
            
            // Check if data is valid
            if (!data || data.length === 0) {
                console.error('No data provided to renderGalleryCards');
                return;
            }
            
            const isMetaList = getURLHashParam('list') === 'all';
            
            data.forEach(participant => {
                if (!participant) return; // Skip null/undefined participants
                const card = document.createElement('div');
                const teamClass = getTeamClass(participant.Team);
                card.className = `gallery-card ${teamClass}`;
                
                const name = getParticipantName(participant);
                card.dataset.participantName = name;
                
                // Add clickable functionality for meta list
                if (isMetaList && participant.Feed) {
                    card.style.cursor = 'pointer';
                    card.title = `Click to view data from: ${participant.Title || participant.Feed}`;
                    card.addEventListener('click', () => {
                        setURLHashParam('list', participant.Feed);
                        updateParticipantListTitle(participant.Title || participant.Feed);
                    });
                }
                const location = participant.Location || 'Location TBD';
                const status = participant.Status || 'Status TBD';
                
                card.innerHTML = `
                    <div class="gallery-name">${name}</div>
                    <div class="gallery-info">${location}</div>
                    <div class="gallery-info">${status}</div>
                `;
                
                container.appendChild(card);
            });
        }
        
        // Sort functionality
        function generateSortDropdown() {
            const sortItems = document.getElementById('sort-items');
            if (!allParticipantsData || !allParticipantsData.length) {
                // Show helpful message when no data is available
                sortItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get available columns from data
            const columns = Object.keys(allParticipantsData[0]);
            
            // Add "Rows" as first option (original order)
            const sortOptions = ['Rows', ...columns];
            
            sortItems.innerHTML = '';
            sortOptions.forEach(column => {
                const sortItem = document.createElement('div');
                sortItem.className = 'sort-item';
                sortItem.dataset.column = column;
                
                const isActive = currentSortColumn === column;
                if (isActive) {
                    sortItem.classList.add('active');
                }
                
                const arrow = currentSortOrder === 'asc' ? '↑' : '↓';
                sortItem.innerHTML = `
                    <span>${column}</span>
                    <span class="sort-arrow">${isActive ? arrow : ''}</span>
                `;
                
                sortItem.addEventListener('click', () => sortBy(column));
                sortItems.appendChild(sortItem);
            });
        }
        
        function sortBy(column) {
            // If clicking the same column, toggle order
            if (currentSortColumn === column) {
                currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                currentSortOrder = 'asc';
            }
            
            // Clear active snapshot since sort changed manually
            clearActiveSnapshot();
            
            // Save sort preferences
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            
            // Note: sortby and sortorder are no longer automatically added to URL hash
            // They are only included in the "Full URL" feature
            
            // Apply sort to data
            applySortToData();
            
            // Update dropdown display
            generateSortDropdown();
            
            // Hide dropdown
            document.getElementById('sort-dropdown').style.display = 'none';
        }
        
        function applySortToData(shouldRerender = true) {
            let sortedData = [...allParticipantsData];
            
            if (currentSortColumn === 'Rows') {
                // Sort by original row order
                if (currentSortOrder === 'desc') {
                    sortedData.reverse();
                } else {
                    sortedData = [...originalDataOrder];
                }
            } else {
                // Sort by column data
                sortedData.sort((a, b) => {
                    let valueA = a[currentSortColumn] || '';
                    let valueB = b[currentSortColumn] || '';
                    
                    // Convert to string for comparison
                    valueA = valueA.toString().toLowerCase();
                    valueB = valueB.toString().toLowerCase();
                    
                    if (currentSortOrder === 'asc') {
                        return valueA.localeCompare(valueB);
                    } else {
                        return valueB.localeCompare(valueA);
                    }
                });
            }
            
            // Update global data
            allParticipantsData = sortedData;
            
            // Re-render all views with current filters applied (only if requested)
            if (shouldRerender) {
                applyAllFilters();
            }
        }
        
        function toggleSortDropdown() {
            const dropdown = document.getElementById('sort-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateSortDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        // Status filtering functionality
        function generateStatusDropdown() {
            const statusItems = document.getElementById('status-items');
            if (!allParticipantsData || !allParticipantsData.length) {
                // Show helpful message when no data is available
                statusItems.innerHTML = '<div class="no-data-message" style="padding: 10px; text-align: center; color: #666; font-style: italic;">Data is loading, please wait...</div>';
                return;
            }
            
            // Get unique status values from data
            const statuses = new Set();
            allParticipantsData.forEach(participant => {
                const status = participant.Status || 'Unknown';
                statuses.add(status);
            });
            
            availableStatuses = ['All', ...Array.from(statuses).sort()];
            
            statusItems.innerHTML = '';
            availableStatuses.forEach(status => {
                const statusItem = document.createElement('div');
                statusItem.className = 'status-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'status-checkbox';
                checkbox.checked = selectedStatuses.has(status);
                checkbox.id = `status-${status}`;
                
                const label = document.createElement('label');
                label.className = 'status-label';
                label.htmlFor = `status-${status}`;
                label.textContent = status;
                
                statusItem.appendChild(checkbox);
                statusItem.appendChild(label);
                
                // Add click handler for the whole item
                statusItem.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox') {
                        checkbox.checked = !checkbox.checked;
                    }
                    handleStatusChange(status, checkbox.checked);
                });
                
                statusItems.appendChild(statusItem);
            });
        }
        
        function handleStatusChange(status, isChecked) {
            // Clear active snapshot since filters changed manually
            clearActiveSnapshot();
            
            // Set flag to prevent group parameter processing during status update
            isUpdatingStatus = true;
            
            if (status === 'All') {
                if (isChecked) {
                    // Check all statuses
                    selectedStatuses.clear();
                    selectedStatuses.add('All');
                    // Update all checkboxes
                    document.querySelectorAll('.status-checkbox').forEach(cb => {
                        cb.checked = cb.id === 'status-All';
                    });
                }
            } else {
                if (isChecked) {
                    // Uncheck "All" and add specific status
                    selectedStatuses.delete('All');
                    selectedStatuses.add(status);
                    document.getElementById('status-All').checked = false;
                } else {
                    // Remove specific status
                    selectedStatuses.delete(status);
                    
                    // If no specific statuses selected, check "All"
                    if (selectedStatuses.size === 0) {
                        selectedStatuses.add('All');
                        document.getElementById('status-All').checked = true;
                    }
                }
            }
            
            // Save to localStorage
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            
            // Update URL hash parameter
            const statusArray = Array.from(selectedStatuses);
            if (statusArray.includes('All') || statusArray.length === 0) {
                // Remove hash parameter for default "All" status
                setURLHashParam('status', null);
            } else {
                setURLHashParam('status', statusArray.join(','));
            }
            
            // Update button text
            updateStatusButtonText();
            
            // Apply filters
            applyAllFilters();
            
            // Clear the flag after a short delay to allow hash changes to settle
            setTimeout(() => {
                isUpdatingStatus = false;
            }, 100);
        }
        
        function updateStatusButtonText() {
            const button = document.getElementById('status-toggle');
            const statusArray = Array.from(selectedStatuses);
            
            if (statusArray.includes('All') || statusArray.length === 0) {
                button.textContent = 'Status';
            } else if (statusArray.length === 1) {
                button.textContent = statusArray[0] + ' Only';
            } else {
                button.textContent = statusArray[0] + '...';
            }
        }
        
        function toggleStatusDropdown() {
            const dropdown = document.getElementById('status-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                generateStatusDropdown();
                dropdown.style.display = 'block';
            }
        }
        
        function applyAllFilters() {
            console.log('🔄 applyAllFilters called');
            console.log('📊 allParticipantsData:', allParticipantsData);
            console.log('📏 allParticipantsData length:', allParticipantsData ? allParticipantsData.length : 'undefined');
            
            if (!allParticipantsData || allParticipantsData.length === 0) {
                console.warn('⚠️ applyAllFilters called but allParticipantsData is empty or undefined');
                console.log('🔍 Current state - selectedStatuses:', selectedStatuses);
                console.log('🔍 Current state - currentTeamFilter:', currentTeamFilter);
                console.log('🔍 Current state - showOnlyGroup:', showOnlyGroup);
                return;
            }
            
            console.log('🏁 Starting filter process with', allParticipantsData.length, 'participants');
            let filteredData = [...allParticipantsData];
            console.log('📋 Initial filteredData length:', filteredData.length);
            
            // Apply group participants filter first if active
            // This ensures team filtering can work on the group subset
            if (showOnlyGroup) {
                console.log('🔍 Applying group participants filter. Group participants:', Array.from(groupParticipants));
                const beforeGroupFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const name = getParticipantName(participant);
                    const passes = Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                    if (!passes) {
                        console.log('❌ Participant filtered out by group status:', name);
                    }
                    return passes;
                });
                console.log('📊 Group filter result:', beforeGroupFilter, '→', filteredData.length);
            } else {
                console.log('⏭️ Skipping group participants filter (not active)');
            }
            
            // Apply team filter if active (works on group-filtered results if group filter is active)
            if (currentTeamFilter) {
                console.log('🔍 Applying team filter:', currentTeamFilter);
                console.log(`🔍 Team filtering ${showOnlyGroup ? 'within group participants' : 'all participants'}`);
                const beforeTeamFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const participantTeamClasses = getAllTeamClasses(participant.Team);
                    const passes = participantTeamClasses.includes(currentTeamFilter);
                    if (!passes) {
                        console.log('❌ Participant filtered out by team:', participant.Name || participant.name, 'Team:', participant.Team, 'Classes:', participantTeamClasses);
                    }
                    return passes;
                });
                console.log('📊 Team filter result:', beforeTeamFilter, '→', filteredData.length);
            } else {
                console.log('⏭️ Skipping team filter (no team selected)');
            }
            
            // Apply status filter last
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                console.log('🔍 Applying status filter. Selected statuses:', Array.from(selectedStatuses));
                const beforeStatusFilter = filteredData.length;
                filteredData = filteredData.filter(participant => {
                    const status = participant.Status || 'Unknown';
                    const passes = selectedStatuses.has(status);
                    if (!passes) {
                        console.log('❌ Participant filtered out by status:', participant.Name || participant.name, 'Status:', status);
                    }
                    return passes;
                });
                console.log('📊 Status filter result:', beforeStatusFilter, '→', filteredData.length);
            } else {
                console.log('⏭️ Skipping status filter (All selected or no selection)');
            }
            
            // Update results count with pagination
            console.log('📊 Updating results count with pagination...');
            updateResultsCount(filteredData);
            
            // Apply pagination to filtered data
            const paginatedData = paginateData(filteredData);
            console.log(`📄 Displaying page ${currentPage} with ${paginatedData.length} records`);
            
            // Render paginated data in all views
            console.log('🎨 Starting render process with', paginatedData.length, 'paginated participants');
            console.log('🔍 Sample of paginated data:', paginatedData.slice(0, 3));
            
            try {
                console.log('🏛️ Rendering column view...');
                renderColumnView(paginatedData);
                console.log('✅ Column view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering column view:', error);
                console.error('Stack trace:', error.stack);
            }
            
            try {
                console.log('📊 Rendering table view...');
                renderTableView(paginatedData);
                console.log('✅ Table view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering table view:', error);
                console.error('Stack trace:', error.stack);
            }
            
            try {
                console.log('🖼️ Rendering gallery view...');
                renderGalleryView(paginatedData);
                console.log('✅ Gallery view rendered successfully');
            } catch (error) {
                console.error('❌ Error rendering gallery view:', error);
                console.error('Stack trace:', error.stack);
            }
            
            // Reapply group highlighting
            console.log('⏰ Scheduling group highlighting update in 100ms...');
            setTimeout(() => {
                console.log('🎨 Executing group highlighting update...');
                try {
                    updateGroupHighlighting();
                    console.log('✅ Group highlighting updated successfully');
                } catch (error) {
                    console.error('❌ Error updating group highlighting:', error);
                }
            }, 100);
            
            console.log('🏁 applyAllFilters completed successfully');
        }
        
        // Switch between views
        function switchView(viewType) {
            currentView = viewType;
            
            // Clear active snapshot since view changed manually
            clearActiveSnapshot();
            
            // Save view preference to localStorage
            localStorage.setItem('participantsViewMode', viewType);
            
            // Update URL hash parameter (don't send 'column' since it's the default)
            if (viewType === 'column') {
                setURLHashParam('display', null); // Remove display parameter for column view
            } else {
                setURLHashParam('display', viewType);
            }
            
            // Hide all views
            document.getElementById('column-view').style.display = 'none';
            document.getElementById('table-view').style.display = 'none';
            document.getElementById('gallery-view').style.display = 'none';
            
            // Show selected view
            document.getElementById(viewType + '-view').style.display = 'block';
            
            // Update button states for expanded view
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(viewType + '-view-btn').classList.add('active');
            
            // Update button states for condensed view
            updateCondensedViewButtons();
            
            // Apply group highlighting after view switch
            setTimeout(() => updateGroupHighlighting(), 100);
            
            // If switching to gallery view and there's a saved team filter, restore it
            if (viewType === 'gallery' && currentTeamFilter && allParticipantsData.length > 0) {
                setTimeout(() => {
                    filterByTeam(currentTeamFilter);
                }, 150);
            }
        }
        
        // Group participants functionality
        function loadGroupParticipants() {
            // Check URL hash parameter first, then fallback to localStorage
            const hashGroup = getURLHashParam('group');
            const stored = localStorage.getItem(getListStorageKey('groupParticipants'));
            const groupInput = document.getElementById('group');
            
            let groupString = '';
            if (hashGroup) {
                // URL hash parameter takes priority
                groupString = hashGroup;
                console.log('🔗 Loading group participants from URL hash:', hashGroup);
            } else if (stored && stored.trim()) {
                // Fallback to localStorage
                groupString = stored;
                console.log('💾 Loading group participants from localStorage:', stored);
            } else {
                console.log('ℹ️ No group participants found in hash or localStorage');
            }
            
            if (groupString && groupInput) {
                // Format the group string with proper spacing (replace commas with ", ")
                const formattedGroupString = groupString.replace(/,/g, ', ');
                
                // Always populate the field with the determined group string (hash takes priority over localStorage)
                groupInput.value = formattedGroupString;
                console.log('✅ Populated group input field with:', formattedGroupString, hashGroup ? '(from hash)' : '(from localStorage)');
                // Scroll to the right to show the end of the text
                setTimeout(() => scrollGroupInputToRight(), 100);
                const parsedNames = groupString.split(',').map(name => name.trim()).filter(name => name);
                groupParticipants = new Set(parsedNames);
                
                // Validate names from any source (hash or localStorage)
                validateGroupNames(parsedNames);
                
                // When loading from hash parameter, respect the user's cached toggle preference
                if (hashGroup) {
                    // Only auto-activate if the user's last choice was to show the group filter
                    // Otherwise, populate the field but respect their preference to show all
                    if (showOnlyGroup) {
                        // User's cached preference is to show group filter, so update hash
                        updateGroupHashParam();
                        console.log('🔄 Hash parameter loaded, group filter active per user preference');
                    } else {
                        console.log('🔄 Hash parameter loaded, but group filter inactive per user preference');
                    }
                    updateGroupToggleUI();
                } else if (stored) {
                    // When loading from localStorage, check if the group filter was previously active
                    // and restore that state (showOnlyGroup is already loaded from localStorage at startup)
                    updateGroupToggleUI();
                    
                    // If group filter is active and we have participants, update hash parameter
                    if (showOnlyGroup && parsedNames.length > 0) {
                        updateGroupHashParam();
                        console.log('🔄 Updated hash parameter from localStorage and restored active filter state');
                    } else {
                        console.log('🔄 Restored group participants from localStorage');
                    }
                }
            } else if (groupString && !groupInput) {
                console.log('⚠️ Group string found but input element not available:', groupString);
            } else if (!groupString && groupInput) {
                // No group data found, ensure field is cleared
                console.log('🧹 No group data found, clearing field and participants');
                groupInput.value = '';
                groupParticipants = new Set();
                hideGroupValidationMessage();
            }
            updateGroupCount();
        }
        
        function scrollGroupInputToRight() {
            const groupInput = document.getElementById('group');
            groupInput.scrollLeft = groupInput.scrollWidth - groupInput.clientWidth;
        }
        
        function saveGroupParticipants() {
            const groupList = Array.from(groupParticipants).join(', ');
            localStorage.setItem(getListStorageKey('groupParticipants'), groupList);
            // Don't overwrite the input field value to preserve user's typing
            
            // Update visibility since we now have stored group participants
            updateGroupParticipantsVisibility();
        }
        
        function updateGroupHashParam() {
            const groupList = Array.from(groupParticipants).join(',');
            if (groupList.trim()) {
                setURLHashParam('group', groupList);
            } else {
                setURLHashParam('group', null); // Remove parameter if empty
            }
        }
        
        function updateGroupCount() {
            const count = groupParticipants.size;
            document.getElementById('group-count').textContent = `(${count})`;
        }
        
        function updateGroupHighlighting() {
            // Remove existing highlighting
            document.querySelectorAll('.participant-group').forEach(el => {
                el.classList.remove('participant-group');
            });
            
            // Apply highlighting to group participants
            groupParticipants.forEach(name => {
                const elements = document.querySelectorAll(`[data-participant-name]`);
                elements.forEach(el => {
                    if (el.dataset.participantName.toLowerCase() === name.toLowerCase()) {
                        el.classList.add('participant-group');
                    }
                });
            });
        }
        
        function processGroupInput() {
            const input = document.getElementById('group');
            const value = input.value;
            
            // Clear active snapshot since group participants changed manually
            clearActiveSnapshot();
            
            // Parse names from input
            groupParticipants = new Set();
            const inputNames = [];
            value.split(',').forEach(name => {
                const trimmed = name.trim();
                if (trimmed) {
                    inputNames.push(trimmed);
                    groupParticipants.add(trimmed);
                }
            });
            
            // Validate names against dataset
            validateGroupNames(inputNames);
            
            // Save to storage and update URL hash
            saveGroupParticipants();
            updateGroupCount();
            updateGroupHighlighting();
            
            // Update URL hash parameter
            updateGroupHashParam();
            
            // If group filter is active, refresh the list to show/hide participants
            if (showOnlyGroup) {
                applyAllFilters();
            }
        }
        
        function validateGroupNames(inputNames) {
            if (!allParticipantsData || allParticipantsData.length === 0) {
                console.log('⏭️ Skipping group name validation - data not yet available');
                return;
            }
            
            if (inputNames.length === 0) {
                // Hide message if no names to validate
                hideGroupValidationMessage();
                return;
            }
            
            // Get all participant names from the dataset
            const datasetNames = allParticipantsData.map(participant => getParticipantName(participant));
            const datasetNamesLower = datasetNames.map(name => name.toLowerCase());
            
            // Find names that don't exist in the dataset
            const notFoundNames = inputNames.filter(inputName => {
                const inputNameLower = inputName.toLowerCase();
                return !datasetNamesLower.includes(inputNameLower);
            });
            
            // Show message if there are names not found
            if (notFoundNames.length > 0) {
                const message = `Not found in dataset: ${notFoundNames.join(', ')}`;
                console.warn('⚠️ ' + message);
                
                // Show a message to the user
                showGroupValidationMessage(message);
            } else {
                // Hide message if all names are valid
                hideGroupValidationMessage();
            }
        }
        
        function showGroupValidationMessage(message) {
            // Create or update validation message element
            let messageEl = document.getElementById('group-validation-message');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'group-validation-message';
                messageEl.style.cssText = `
                    color: #d97706;
                    font-size: 12px;
                    margin-top: 4px;
                    padding: 4px 8px;
                    background: #fef3c7;
                    border: 1px solid #f59e0b;
                    border-radius: 4px;
                    display: none;
                `;
                
                // Insert after the group control
                const groupControl = document.getElementById('group-control');
                if (groupControl && groupControl.parentNode) {
                    groupControl.parentNode.insertBefore(messageEl, groupControl.nextSibling);
                }
            }
            
            messageEl.textContent = message;
            messageEl.style.display = 'block';
        }
        
        function hideGroupValidationMessage() {
            const messageEl = document.getElementById('group-validation-message');
            if (messageEl) {
                messageEl.style.display = 'none';
            }
        }
        
        function toggleGroupFilter() {
            showOnlyGroup = !showOnlyGroup;
            
            // Clear active snapshot since filter changed manually
            clearActiveSnapshot();
            
            // Save state to localStorage
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            // Note: Group toggle button does not alter URL hash
            // Hash is only updated when group participants are manually edited
            
            updateGroupToggleUI();
            
            // Apply all filters (includes group participant filtering)
            applyAllFilters();
        }
        
        function updateGroupToggleUI() {
            const toggle = document.getElementById('group-toggle');
            const toggleText = document.getElementById('group-toggle-text');
            
            // Get cached text choices or use defaults
            const cachedActiveText = localStorage.getItem(getListStorageKey('groupToggleActiveText')) || 'All';
            const cachedInactiveText = localStorage.getItem(getListStorageKey('groupToggleInactiveText')) || 'Present';
            
            if (showOnlyGroup) {
                toggle.classList.add('active');
                toggleText.textContent = cachedActiveText;
            } else {
                toggle.classList.remove('active');
                toggleText.textContent = cachedInactiveText;
            }
        }
        
        function shouldShowGroupParticipants() {
            // Check if URL contains #list=team or any variant with "team"
            const urlParams = new URLSearchParams(window.location.search);
            const listParam = urlParams.get('list');
            const hashParams = window.location.hash.substring(1); // Remove #
            const hasTeamInUrl = (listParam && listParam.toLowerCase().includes('team')) ||
                                hashParams.toLowerCase().includes('list=team') ||
                                hashParams.toLowerCase().includes('list=modelteam');
            
            // Check if there are already stored group participants
            const storedGroup = localStorage.getItem(getListStorageKey('groupParticipants'));
            const hasStoredGroup = storedGroup && storedGroup.trim() !== '';
            
            return hasTeamInUrl || hasStoredGroup;
        }
        
        function updateGroupParticipantsVisibility() {
            const groupControl = document.getElementById('group-control');
            if (groupControl) {
                if (shouldShowGroupParticipants()) {
                    groupControl.style.display = 'block';
                } else {
                    groupControl.style.display = 'none';
                }
            }
        }
        
        // Data preprocessing functions for column name normalization
        function detectCommonPrefix(columns) {
            if (columns.length === 0) return '';
            
            // Find the shortest column name to limit prefix length
            const minLength = Math.min(...columns.map(col => col.length));
            if (minLength === 0) return '';
            
            let commonPrefix = '';
            
            // Check each character position
            for (let i = 0; i < minLength; i++) {
                const char = columns[0][i];
                
                // Check if all columns have the same character at this position
                const allMatch = columns.every(col => col[i] === char);
                
                if (allMatch) {
                    commonPrefix += char;
                } else {
                    break;
                }
            }
            
            // Only return prefix if it ends with an underscore or is substantial
            // and all columns would still have meaningful names after removal
            if (commonPrefix.length > 2 && 
                (commonPrefix.endsWith('_') || commonPrefix.length >= 4)) {
                
                // Verify all columns would have meaningful names after prefix removal
                const wouldBeValid = columns.every(col => {
                    const remaining = col.substring(commonPrefix.length);
                    return remaining.length > 0 && remaining !== '_';
                });
                
                if (wouldBeValid) {
                    return commonPrefix;
                }
            }
            
            return '';
        }
        
        function preprocessParticipantData(participants) {
            if (!Array.isArray(participants) || participants.length === 0) {
                return participants;
            }
            
            return participants.map(participant => {
                // Create a new object to maintain original data
                const processed = {};
                
                // Step 1: Get all column names
                const allColumns = Object.keys(participant);
                const commonPrefix = detectCommonPrefix(allColumns);
                
                // Step 2: Create a mapping of original to cleaned column names
                const columnMapping = {};
                allColumns.forEach(col => {
                    let cleanedName = col;
                    if (commonPrefix && col.startsWith(commonPrefix)) {
                        cleanedName = col.substring(commonPrefix.length);
                        // Ensure the cleaned name doesn't start with underscore
                        if (cleanedName.startsWith('_')) {
                            cleanedName = cleanedName.substring(1);
                        }
                    }
                    columnMapping[col] = cleanedName;
                });
                
                // Step 3: Identify ID columns and add them first (using cleaned names)
                const idColumns = [];
                const otherColumns = [];
                
                Object.entries(columnMapping).forEach(([originalKey, cleanedKey]) => {
                    if (cleanedKey === 'id' || cleanedKey.endsWith('_id') || cleanedKey.endsWith('ID') || cleanedKey === 'ID') {
                        idColumns.push({ original: originalKey, cleaned: cleanedKey });
                    } else {
                        otherColumns.push({ original: originalKey, cleaned: cleanedKey });
                    }
                });
                
                // Sort ID columns (id first, then others alphabetically)
                idColumns.sort((a, b) => {
                    if (a.cleaned === 'id') return -1;
                    if (b.cleaned === 'id') return 1;
                    return a.cleaned.localeCompare(b.cleaned);
                });
                
                // Step 4: Add ID columns first
                idColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                // Step 5: Handle description -> title conversion
                const descriptionColumn = otherColumns.find(({ cleaned, original }) => 
                    cleaned === 'description' || 
                    original === 'project_description' ||
                    cleaned === 'project_description'
                );
                
                if (descriptionColumn && participant[descriptionColumn.original] !== undefined && 
                    participant[descriptionColumn.original] !== null && participant[descriptionColumn.original] !== '') {
                    processed.title = participant[descriptionColumn.original];
                    // Remove from otherColumns to avoid duplication
                    const index = otherColumns.indexOf(descriptionColumn);
                    if (index > -1) {
                        otherColumns.splice(index, 1);
                    }
                } else {
                    // Check for existing title
                    const titleColumn = otherColumns.find(({ cleaned }) => cleaned === 'title');
                    if (titleColumn && participant[titleColumn.original] !== undefined && 
                        participant[titleColumn.original] !== null && participant[titleColumn.original] !== '') {
                        processed.title = participant[titleColumn.original];
                        // Remove from otherColumns to avoid duplication
                        const index = otherColumns.indexOf(titleColumn);
                        if (index > -1) {
                            otherColumns.splice(index, 1);
                        }
                    }
                }
                
                // Step 6: Add Name column only if no existing name field is found
                // Check if there's already a name column in the data
                const existingNameColumn = otherColumns.find(({ cleaned }) => 
                    cleaned === 'name' || 
                    cleaned === 'participant_name' ||
                    cleaned === 'full_name' ||
                    cleaned === 'display_name'
                );
                
                // Only add a Name column if no existing name column is found
                if (!existingNameColumn) {
                    let nameField = null;
                    
                    if (processed.title && processed.title !== '') {
                        // Use title field as name
                        nameField = processed.title;
                    } else if (otherColumns.length > 0) {
                        // Use first non-ID column as name
                        const firstColumn = otherColumns[0];
                        nameField = participant[firstColumn.original] || '';
                        console.log('Name field logic - using column:', firstColumn.cleaned, 'value:', nameField);
                    } else {
                        // Final fallback
                        nameField = 'Unknown';
                    }
                    
                    // Add as "Name" column (not "displayName")
                    processed.Name = nameField;
                }
                
                // Step 7: Add remaining columns with cleaned names
                otherColumns.forEach(({ original, cleaned }) => {
                    processed[cleaned] = participant[original];
                });
                
                return processed;
            });
        }
        
        function getParticipantName(participant) {
            // Helper function to get the appropriate name field from a participant object
            // Checks for various name field variations and returns the value
            if (!participant || typeof participant !== 'object') {
                return 'Unknown';
            }
            
            const nameFields = ['Name', 'name', 'participant_name', 'full_name', 'display_name', 'displayName'];
            
            for (const field of nameFields) {
                if (participant[field] !== undefined && participant[field] !== null && participant[field] !== '') {
                    return participant[field];
                }
            }
            
            return 'Unknown';
        }
        
        // Raw data functionality
        let originalRawData = null;
        let rawDataVisible = false;
        
        function toggleRawData() {
            rawDataVisible = !rawDataVisible;
            const rawDataControl = document.getElementById('raw-data-control');
            const rawDataEditor = document.getElementById('raw-data-editor');
            const rawDataText = document.getElementById('raw-data-text');
            const rawDataSource = document.getElementById('raw-data-source');
            
            if (rawDataVisible) {
                // Show raw data editor
                rawDataControl.style.display = 'block';
                rawDataText.textContent = 'Hide Raw Data';
                
                // Store original data and populate editor
                originalRawData = JSON.parse(JSON.stringify(participantsData));
                rawDataEditor.value = JSON.stringify(participantsData, null, 2);
                
                // Populate data source field
                const currentSource = getCurrentDataSource();
                rawDataSource.value = currentSource;
            } else {
                // Hide raw data editor
                rawDataControl.style.display = 'none';
                rawDataText.textContent = 'View Raw Data';
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function getCurrentDataSource() {
            // Get current data source based on selection and hash parameters
            const listParam = getURLHashParam('list');
            
            if (listParam === 'all') {
                return 'Meta-list: All Available Feeds';
            } else if (selectedFile === 'all') {
                return 'Meta-list: All Available Feeds';
            } else if (selectedFile && selectedFile.startsWith('http')) {
                return selectedFile;
            } else if (selectedFile && selectedFile.startsWith('custom_')) {
                return `Custom file: ${selectedFile.replace('custom_', '')}`;
            } else {
                // Try to get URL from selected dropdown option
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                const dataUrl = selectedOption?.getAttribute('data-url');
                
                if (dataUrl && dataUrl !== 'all') {
                    return dataUrl;
                } else {
                    return selectedOption?.textContent || 'Unknown data source';
                }
            }
        }
        
        function applyRawDataChanges() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            try {
                // Parse the edited JSON
                const editedData = JSON.parse(rawDataEditor.value);
                
                // Validate that it's an array
                if (!Array.isArray(editedData)) {
                    throw new Error('Data must be an array of participants');
                }
                
                // Update the global participants data
                participantsData = editedData;
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data changes applied successfully', 'success');
                
            } catch (error) {
                // Show error message
                showStatusMessage('Error parsing JSON: ' + error.message, 'error');
                console.error('Raw data parsing error:', error);
            }
        }
        
        function revertRawData() {
            const rawDataEditor = document.getElementById('raw-data-editor');
            
            if (originalRawData) {
                // Restore original data
                participantsData = JSON.parse(JSON.stringify(originalRawData));
                rawDataEditor.value = JSON.stringify(originalRawData, null, 2);
                
                // Apply all filters and refresh the display
                applyAllFilters();
                
                // Show success message
                showStatusMessage('Raw data reverted to original', 'info');
            }
        }
        
        function closeRawData() {
            // Close the raw data editor if it's open
            if (rawDataVisible) {
                toggleRawData();
            }
        }
        
        function showStatusMessage(message, type = 'info') {
            // Create or update status message element
            let statusEl = document.getElementById('raw-data-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'raw-data-status';
                statusEl.className = 'status-message';
                document.getElementById('raw-data-control').appendChild(statusEl);
            }
            
            // Set message and type
            statusEl.textContent = message;
            statusEl.className = `status-message ${type}`;
            statusEl.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }
        
        function exportCSVFromMenu() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Call the existing export CSV functionality
            exportParticipantsCSV();
        }
        
        // Snapshot functionality
        let currentActiveSnapshot = null;
        
        function getSnapshotsStorageKey() {
            const listId = getURLHashParam('list') || 'default';
            return `${listId}_1_snapshots`;
        }
        
        function loadSnapshots() {
            const snapshots = JSON.parse(localStorage.getItem(getSnapshotsStorageKey()) || '{}');
            return snapshots;
        }
        
        function saveSnapshots(snapshots) {
            localStorage.setItem(getSnapshotsStorageKey(), JSON.stringify(snapshots));
        }
        
        function getCurrentFilterState() {
            return {
                sortColumn: currentSortColumn,
                sortOrder: currentSortOrder,
                teamFilter: currentTeamFilter,
                displayMode: currentView,
                statusFilter: Array.from(selectedStatuses),
                groupParticipants: Array.from(groupParticipants),
                showOnlyGroup: showOnlyGroup
            };
        }
        
        function applyFilterState(filterState) {
            // Apply sort
            currentSortColumn = filterState.sortColumn || 'Rows';
            currentSortOrder = filterState.sortOrder || 'asc';
            localStorage.setItem(getListStorageKey('participantsSortColumn'), currentSortColumn);
            localStorage.setItem(getListStorageKey('participantsSortOrder'), currentSortOrder);
            applySortToData();
            generateSortDropdown();
            
            // Apply team filter
            currentTeamFilter = filterState.teamFilter || null;
            if (currentTeamFilter) {
                localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
            } else {
                localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            }
            
            // Apply display mode
            if (filterState.displayMode && filterState.displayMode !== currentView) {
                switchView(filterState.displayMode);
            }
            
            // Apply status filter
            selectedStatuses = new Set(filterState.statusFilter || ['All']);
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
            updateStatusButtonText();
            generateStatusDropdown();
            
            // Apply group participants
            groupParticipants = new Set(filterState.groupParticipants || []);
            showOnlyGroup = filterState.showOnlyGroup || false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), JSON.stringify(showOnlyGroup));
            
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = Array.from(groupParticipants).join(', ');
            }
            updateGroupCount();
            updateGroupToggleUI();
            
            // Apply all filters
            applyAllFilters();
        }
        
        function saveSnapshot(name) {
            const snapshots = loadSnapshots();
            const filterState = getCurrentFilterState();
            snapshots[name] = filterState;
            saveSnapshots(snapshots);
            renderSnapshotsList();
        }
        
        function loadSnapshot(name) {
            const snapshots = loadSnapshots();
            if (snapshots[name]) {
                currentActiveSnapshot = name;
                applyFilterState(snapshots[name]);
                updateListTitle();
            }
        }
        
        function deleteSnapshot(name) {
            const snapshots = loadSnapshots();
            delete snapshots[name];
            saveSnapshots(snapshots);
            if (currentActiveSnapshot === name) {
                currentActiveSnapshot = null;
                updateListTitle();
            }
            renderSnapshotsList();
        }
        
        function renderSnapshotsList() {
            const snapshots = loadSnapshots();
            const snapshotsList = document.getElementById('snapshots-list');
            
            snapshotsList.innerHTML = '';
            
            Object.keys(snapshots).forEach(name => {
                const snapshotItem = document.createElement('div');
                snapshotItem.className = 'snapshot-item';
                
                snapshotItem.innerHTML = `
                    <input type="text" class="snapshot-name" value="${name}" readonly>
                    <button class="snapshot-save-btn" title="Save current filters">■</button>
                `;
                
                const nameInput = snapshotItem.querySelector('.snapshot-name');
                const saveBtn = snapshotItem.querySelector('.snapshot-save-btn');
                
                // Click snapshot name to load it
                nameInput.addEventListener('click', () => {
                    if (!nameInput.classList.contains('editing')) {
                        loadSnapshot(name);
                        toggleSnapshots();
                    }
                });
                
                // Double-click to edit name
                nameInput.addEventListener('dblclick', () => {
                    nameInput.classList.add('editing');
                    nameInput.readOnly = false;
                    nameInput.select();
                });
                
                // Save name on blur or enter
                nameInput.addEventListener('blur', () => saveSnapshotName(nameInput, name));
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveSnapshotName(nameInput, name);
                    }
                });
                
                // Save button - save current filter state to this snapshot
                saveBtn.addEventListener('click', () => {
                    saveSnapshot(name);
                    // Set as current active snapshot and update title
                    currentActiveSnapshot = name;
                    updateListTitle();
                    alert(`Snapshot "${name}" updated with current filters and activated!`);
                });
                
                snapshotsList.appendChild(snapshotItem);
            });
        }
        
        function saveSnapshotName(input, oldName) {
            const newName = input.value.trim();
            if (newName && newName !== oldName) {
                const snapshots = loadSnapshots();
                snapshots[newName] = snapshots[oldName];
                delete snapshots[oldName];
                saveSnapshots(snapshots);
                
                if (currentActiveSnapshot === oldName) {
                    currentActiveSnapshot = newName;
                    updateListTitle();
                }
                
                renderSnapshotsList();
            } else {
                input.value = oldName;
            }
            input.classList.remove('editing');
            input.readOnly = true;
        }
        
        function toggleSnapshots() {
            const snapshotsControl = document.getElementById('snapshots-control');
            const isVisible = snapshotsControl.style.display === 'block';
            
            if (isVisible) {
                snapshotsControl.style.display = 'none';
            } else {
                snapshotsControl.style.display = 'block';
                renderSnapshotsList();
            }
            
            // Close menu
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
        }
        
        function addNewSnapshot() {
            const nameInput = document.getElementById('new-snapshot-name');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a snapshot name');
                return;
            }
            
            const snapshots = loadSnapshots();
            if (snapshots[name]) {
                if (!confirm(`Snapshot "${name}" already exists. Overwrite?`)) {
                    return;
                }
            }
            
            saveSnapshot(name);
            // Set as current active snapshot and update title
            currentActiveSnapshot = name;
            updateListTitle();
            nameInput.value = '';
            alert(`Snapshot "${name}" saved and activated!`);
        }
        
        function updateListTitle() {
            const listTitle = document.getElementById('list-title');
            const baseTitle = listTitle.textContent.split(' - ')[0]; // Remove existing snapshot name
            
            if (currentActiveSnapshot) {
                listTitle.textContent = `${baseTitle} - ${currentActiveSnapshot}`;
            } else {
                listTitle.textContent = baseTitle;
            }
        }
        
        function clearActiveSnapshot() {
            if (currentActiveSnapshot) {
                currentActiveSnapshot = null;
                updateListTitle();
                console.log('🔄 Cleared active snapshot due to manual filter change');
            }
        }
        
        function loadSnapshotOnPageLoad() {
            const snapshots = loadSnapshots();
            if (snapshots['1']) {
                loadSnapshot('1');
            }
        }
        
        function generateFullURL() {
            // Close menu first
            document.getElementById('menu-toggle').classList.remove('active');
            document.getElementById('menu-dropdown').classList.remove('active');
            
            // Start with current URL without hash
            const baseUrl = window.location.origin + window.location.pathname + window.location.search;
            const params = new URLSearchParams();
            
            // Add current hash parameters
            const currentHash = window.location.hash.substring(1);
            if (currentHash) {
                const hashParams = new URLSearchParams(currentHash);
                hashParams.forEach((value, key) => {
                    params.set(key, value);
                });
            }
            
            // Add sort parameters from localStorage
            if (currentSortColumn && currentSortColumn !== 'Rows') {
                params.set('sortby', currentSortColumn);
            }
            if (currentSortOrder && currentSortOrder !== 'asc') {
                params.set('sortorder', currentSortOrder);
            }
            
            // Add team filter if active
            if (currentTeamFilter) {
                params.set('team', currentTeamFilter);
            }
            
            // Add display mode if not default
            if (currentView && currentView !== 'column') {
                params.set('display', currentView);
            }
            
            // Add status filter if not "All"
            const statusArray = Array.from(selectedStatuses);
            if (!statusArray.includes('All') && statusArray.length > 0) {
                params.set('status', statusArray.join(','));
            }
            
            // Add group participants if any
            if (groupParticipants.size > 0) {
                params.set('group', Array.from(groupParticipants).join(','));
            }
            
            // Generate full URL
            const fullUrl = params.toString() ? `${baseUrl}#${params.toString()}` : baseUrl;
            
            // Copy to clipboard
            navigator.clipboard.writeText(fullUrl).then(() => {
                // Show success message
                alert('Full URL copied to clipboard!\n\nThe URL includes all current filters:\n- Sort settings\n- Team filter\n- Status filter\n- Group participants\n- Display mode');
                console.log('📋 Full URL copied to clipboard:', fullUrl);
            }).catch(err => {
                // Fallback for older browsers
                console.error('Failed to copy to clipboard:', err);
                alert('Full URL:\n\n' + fullUrl + '\n\n(Please copy manually)');
            });
        }
        
        function exportParticipantsCSV() {
            console.log('exportParticipantsCSV called');
            console.log('window.participantsData:', window.participantsData);
            console.log('allParticipantsData:', allParticipantsData);
            
            if (!window.participantsData || window.participantsData.length === 0) {
                // Try using allParticipantsData as fallback
                if (allParticipantsData && allParticipantsData.length > 0) {
                    console.log('Using allParticipantsData as fallback');
                    window.participantsData = allParticipantsData;
                } else {
                    alert('No participant data to export');
                    return;
                }
            }
            
            // Determine which data to export based on current filter state
            let dataToExport = window.participantsData;
            
            // Generate date string for filename (YYYY-MM-DD format)
            const today = new Date();
            const dateString = today.getFullYear() + '-' + 
                String(today.getMonth() + 1).padStart(2, '0') + '-' + 
                String(today.getDate()).padStart(2, '0');
            
            let filename = `meetup-participants-${dateString}.csv`;
            
            // Apply team filter if active
            if (currentTeamFilter && currentTeamFilter !== 'all') {
                dataToExport = dataToExport.filter(participant => {
                    const teamClasses = getAllTeamClasses(participant.Team);
                    return teamClasses.includes(currentTeamFilter);
                });
                const teamName = teamColors[currentTeamFilter.replace('team-', '')] ? 
                    teamColors[currentTeamFilter.replace('team-', '')].name : 'filtered';
                filename = `meetup-participants-${teamName}-${dateString}.csv`;
            }
            
            // Apply status filter if active (using selectedStatuses)
            if (!selectedStatuses.has('All') && selectedStatuses.size > 0) {
                const statusList = Array.from(selectedStatuses);
                dataToExport = dataToExport.filter(participant => {
                    const status = participant.Status || '';
                    return statusList.includes(status);
                });
                filename = `meetup-participants-${statusList.join('-')}-${dateString}.csv`;
            }
            
            // If showing only group participants, export only those
            if (showOnlyGroup) {
                dataToExport = dataToExport.filter(participant => {
                    const name = getParticipantName(participant);
                    return Array.from(groupParticipants).some(groupName => 
                        groupName.toLowerCase() === name.toLowerCase()
                    );
                });
                filename = `meetup-participants-group-${dateString}.csv`;
            }
            
            if (dataToExport.length === 0) {
                alert('No participants match the current filters');
                return;
            }
            
            console.log('About to export', dataToExport.length, 'rows');
            const headers = Object.keys(dataToExport[0]);
            console.log('Headers:', headers);
            
            // Create CSV content
            let csvContent = headers.join(',') + '\n';
            dataToExport.forEach(row => {
                const values = headers.map(header => {
                    const value = row[header] || '';
                    // Escape quotes and wrap in quotes if contains comma
                    return value.includes(',') ? `"${value.replace(/"/g, '""')}"` : value;
                });
                csvContent += values.join(',') + '\n';
            });
            
            // Download CSV
            console.log('Creating CSV download with filename:', filename);
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            console.log('Triggering download...');
            link.click();
            document.body.removeChild(link);
            console.log('CSV export completed');
        }

        getParticipantsButton.addEventListener('click', getMeetupParticipants);
        

        // View switching event listeners
        document.getElementById('column-view-btn').addEventListener('click', () => switchView('column'));
        document.getElementById('table-view-btn').addEventListener('click', () => switchView('table'));
        document.getElementById('gallery-view-btn').addEventListener('click', () => switchView('gallery'));
        
        // Team filter event listener (now handled in generateTeamLegend function)
        
        // Sort event listeners
        document.getElementById('sort-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleSortDropdown();
        });
        document.getElementById('close-sort').addEventListener('click', () => {
            document.getElementById('sort-dropdown').style.display = 'none';
        });
        
        // Status event listeners
        document.getElementById('status-toggle').addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            toggleStatusDropdown();
        });
        document.getElementById('close-status').addEventListener('click', () => {
            document.getElementById('status-dropdown').style.display = 'none';
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const sortDropdown = document.getElementById('sort-dropdown');
            const sortToggle = document.getElementById('sort-toggle');
            const statusDropdown = document.getElementById('status-dropdown');
            const statusToggle = document.getElementById('status-toggle');
            
            if (!sortDropdown.contains(e.target) && !sortToggle.contains(e.target)) {
                sortDropdown.style.display = 'none';
            }
            
            if (!statusDropdown.contains(e.target) && !statusToggle.contains(e.target)) {
                statusDropdown.style.display = 'none';
            }
        });
        
        // Group participants event listeners
        const groupInput = document.getElementById('group');
        groupInput.addEventListener('input', function(e) {
            const value = e.target.value;
            // Process input when comma is typed, but preserve the comma
            if (value.endsWith(',')) {
                // Extract the part before the comma for processing
                const beforeComma = value.substring(0, value.length - 1);
                if (beforeComma.trim()) {
                    // Process the names before the comma
                    const names = beforeComma.split(',').map(name => name.trim()).filter(name => name);
                    names.forEach(name => {
                        if (name) groupParticipants.add(name);
                    });
                    
                    // Validate names against dataset
                    validateGroupNames(names);
                    
                    // Save to storage and update highlighting
                    saveGroupParticipants();
                    updateGroupCount();
                    updateGroupHighlighting();
                    
                    // Update URL hash parameter
                    updateGroupHashParam();
                }
            }
        });
        
        groupInput.addEventListener('keydown', function(e) {
            // Process input when Enter is pressed
            if (e.key === 'Enter') {
                e.preventDefault();
                processGroupInput();
            }
        });
        
        groupInput.addEventListener('blur', function() {
            // Process input when field loses focus
            processGroupInput();
            // Only scroll to the right if already near the right edge
            if (groupInput.scrollLeft >= groupInput.scrollWidth - groupInput.clientWidth - 10) {
                setTimeout(() => scrollGroupInputToRight(), 10); // Very fast, 10th of 10th
            }
        });
        
        document.getElementById('group-toggle').addEventListener('click', toggleGroupFilter);
        
        // Group toggle text editing functionality
        const groupToggleText = document.getElementById('group-toggle-text');
        
        // Make toggle text editable on double-click
        groupToggleText.addEventListener('dblclick', function() {
            const currentText = this.textContent;
            this.contentEditable = true;
            this.focus();
            
            // Select all text for easy editing
            const range = document.createRange();
            range.selectNodeContents(this);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        });
        
        // Save changes when editing is complete
        groupToggleText.addEventListener('blur', function() {
            this.contentEditable = false;
            const newText = this.textContent.trim();
            
            if (newText) {
                // Save the new text based on current toggle state
                if (showOnlyGroup) {
                    localStorage.setItem(getListStorageKey('groupToggleActiveText'), newText);
                } else {
                    localStorage.setItem(getListStorageKey('groupToggleInactiveText'), newText);
                }
                console.log(`💾 Saved group toggle text: "${newText}" for ${showOnlyGroup ? 'active' : 'inactive'} state`);
            } else {
                // Restore previous text if empty
                updateGroupToggleUI();
            }
        });
        
        // Save changes when Enter is pressed
        groupToggleText.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur(); // Trigger blur event to save
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                // Restore original text and exit editing
                updateGroupToggleUI();
                this.contentEditable = false;
            }
        });
        
        // Raw data event listeners
        document.getElementById('apply-raw-data').addEventListener('click', applyRawDataChanges);
        document.getElementById('revert-raw-data').addEventListener('click', revertRawData);
        document.getElementById('raw-data-close').addEventListener('click', closeRawData);
        
        // Hide UI elements when changing to a new list
        function hideListDisplayElements() {
            // Hide team legend panel
            const teamLegend = document.getElementById('team-legend');
            if (teamLegend) {
                teamLegend.style.display = 'none';
            }
            
            // Hide view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'none';
            }
            
            // Hide table view and other views
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            console.log('List display elements hidden');
        }
        
        // Show UI elements when new list loads successfully
        function showListDisplayElements() {
            // Show view controls
            const viewControls = document.querySelector('.view-controls');
            if (viewControls) {
                viewControls.style.display = 'flex';
            }
            
            // Show the current view based on currentView setting
            const tableView = document.getElementById('table-view');
            const columnView = document.getElementById('column-view');
            const galleryView = document.getElementById('gallery-view');
            
            // Hide all views first
            if (tableView) tableView.style.display = 'none';
            if (columnView) columnView.style.display = 'none';
            if (galleryView) galleryView.style.display = 'none';
            
            // Show the current view
            if (currentView === 'table' && tableView) {
                tableView.style.display = 'block';
            } else if (currentView === 'gallery' && galleryView) {
                galleryView.style.display = 'block';
            } else if (columnView) {
                // Default to column view
                columnView.style.display = 'block';
            }
            
            // Team legend will be shown by generateTeamLegend if there's a Team column
            
            console.log('List display elements shown');
        }
        
        // Update menu visibility based on current list
        function updateMenuVisibility() {
            const listParam = getURLHashParam('list');
            const allFeedsToggle = document.getElementById('list-feeds-toggle');
            
            if (allFeedsToggle) {
                // Hide "All Feeds" option when already viewing all feeds
                if (listParam === 'all' || fileSelect.value === 'all') {
                    allFeedsToggle.style.display = 'none';
                } else {
                    allFeedsToggle.style.display = 'block';
                }
            }
        }
        
        // Clear all filters when changing lists
        function clearAllFilters() {
            // Clear team filter
            currentTeamFilter = null;
            localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
            
            // Clear status filter - reset to "All"
            selectedStatuses.clear();
            selectedStatuses.add('All');
            localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(['All']));
            
            // Clear group participants filter
            showOnlyGroup = false;
            localStorage.setItem(getListStorageKey('showOnlyGroup'), 'false');
            const groupInput = document.getElementById('group');
            if (groupInput) {
                groupInput.value = '';
            }
            groupParticipants = new Set();
            updateGroupCount();
            
            // Hide validation message
            hideGroupValidationMessage();
            
            // Clear URL hash parameters (sortby/sortorder are not in hash anymore)
            setURLHashParam('group', null);
            setURLHashParam('status', null);
            
            // Reset team legend flag to allow regeneration
            initialTeamLegendGenerated = false;
            
            console.log('All filters cleared for new list selection');
        }
        
        // File selection handling functions
        function handleFileDropdownChange() {
            const value = fileSelect.value;
            
            // Clear previous results
            statusMessages.innerHTML = '';
            document.getElementById('loadStatus').style.display = 'none';
            
            // Clear all filters when selecting a new list
            clearAllFilters();
            
            // Hide UI elements when changing to a new list
            hideListDisplayElements();
            
            // Update the participant list title
            updateParticipantListTitle();
            
            // Update menu visibility
            updateMenuVisibility();
            
            if (value === 'custom') {
                // Show custom file upload section
                customFileSection.style.display = 'block';
                selectedFile = null;
            } else if (value.startsWith('custom_')) {
                // This is a previously uploaded custom file
                const fileName = value.replace('custom_', '');
                const customFile = customFiles[fileName];
                if (customFile) {
                    selectedFile = customFile;
                    customFileSection.style.display = 'none';
                }
            } else {
                // Hide custom file upload and use predefined file
                customFileSection.style.display = 'none';
                
                // Check if "All Lists" option is selected
                if (value === 'all') {
                    selectedFile = 'all';
                    console.log('Selected option: All Lists - showing meta list');
                    
                    // Show all feeds meta list
                    showAllFeeds();
                } else {
                    // Get the selected option to check for data attributes
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    const dataUrl = selectedOption.getAttribute('data-url');
                    
                    if (dataUrl) {
                        selectedFile = dataUrl;
                        console.log(`Selected option: ${selectedOption.textContent} (${value}) - URL: ${dataUrl}`);
                        
                        // Auto-refresh the list when selection changes
                        getMeetupParticipants();
                    }
                }
            }
            
            // Save selection to storage (use 'list=' instead of 'feed=')
            if (value !== 'custom') {
                saveFileSelectionToStorage(value, STORAGE_KEY);
                updateListHashParam(value);
            }
        }
        
        function updateParticipantListTitle(customTitle = null) {
            const participantListTitle = document.getElementById('list-title');
            let titleText;
            
            if (customTitle) {
                // Use custom title provided
                titleText = customTitle;
                participantListTitle.textContent = `📊 ${customTitle}`;
            } else {
                // Check if there's a list parameter in the hash
                const listParam = getURLHashParam('list');
                if (listParam) {
                    // Look for matching option in dropdown to get proper title
                    const matchingOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (matchingOption && matchingOption.textContent) {
                        titleText = matchingOption.textContent;
                        participantListTitle.textContent = `📊 ${matchingOption.textContent}`;
                    } else {
                        // Use the list parameter value as title if no matching option found
                        titleText = listParam;
                        participantListTitle.textContent = `📊 ${listParam}`;
                    }
                } else {
                    const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                    if (selectedOption && selectedOption.textContent && selectedOption.value !== 'custom') {
                        // Use the title from the selected option
                        titleText = selectedOption.textContent;
                        participantListTitle.textContent = `📊 ${selectedOption.textContent}`;
                    } else {
                        // Default title
                        titleText = 'Participants List';
                        participantListTitle.textContent = '📊 Participants List';
                    }
                }
            }
            
            // Update browser title
            document.title = titleText;
        }
        
        // Show/hide header based on list parameter
        function updateHeaderVisibility() {
            const listParam = getURLHashParam('list');
            const header = document.querySelector('.header');
            
            if (header) {
                // Only show header when list=modelteam
                header.style.display = (listParam === 'modelteam') ? 'block' : 'none';
                console.log('Header visibility updated:', listParam === 'modelteam' ? 'visible' : 'hidden', 'for list:', listParam);
            }
        }
        
        // Update both header visibility and title when hash changes
        function updateUIForHashChange() {
            updateHeaderVisibility();
            updateParticipantListTitle();
            
            // Clear status messages when list changes
            statusMessages.innerHTML = '';
        }
        
        function handleCustomFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Store the file object
            customFiles[file.name] = file;
            selectedFile = file;
            
            // Add the new file to the dropdown
            const fileName = file.name;
            const fileValue = `custom_${fileName}`;
            
            // Check if this file is already in the dropdown
            let existingOption = Array.from(fileSelect.options).find(option => option.value === fileValue);
            if (!existingOption) {
                // Add new option before "Choose File..."
                const newOption = document.createElement('option');
                newOption.value = fileValue;
                newOption.textContent = fileName;
                newOption.selected = true;
                
                // Insert before the "Choose File..." option (last option)
                fileSelect.insertBefore(newOption, fileSelect.lastElementChild);
            } else {
                // Select the existing option
                existingOption.selected = true;
            }
            
            // Update display
            const fileSize = (file.size / 1024 / 1024).toFixed(2);
            const fileType = file.name.toLowerCase().endsWith('.csv') ? 'CSV' : 'Excel';
            fileDisplay.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-details">${fileType} file, ${fileSize} MB</div>
                </div>
            `;
            
            // Hide custom file section
            customFileSection.style.display = 'none';
        }
        
        // Hash parameter utility functions are now available from list.js
        // getURLHashParam, setURLHashParam, updateListHashParam
        
        async function initializeFileSelection() {
            // Use shared function for Google Sheet loading and initialization
            const selectedOption = await initializeFileSelectionWithGoogleSheet(fileSelect, 'list', STORAGE_KEY);
            
            // Add "All Lists" option after dynamic options are loaded
            addAllListsOption();
            
            // Check if list=all is in hash parameter and select "All Lists" option
            const listParam = getURLHashParam('list');
            if (listParam === 'all') {
                fileSelect.value = 'all';
                selectedFile = 'all';
            } else {
                selectedFile = selectedOption.getAttribute('data-url') || selectedOption.value;
            }
            
            // Update the participant list title with the selected option
            updateParticipantListTitle();
            
            // Add event listeners
            fileSelect.addEventListener('change', handleFileDropdownChange);
            fileInput.addEventListener('change', handleCustomFileSelect);
            
            // Make file display clickable
            fileDisplay.addEventListener('click', () => {
                fileInput.click();
            });
        }
        
        function addAllListsOption() {
            // Check if "All Lists" option already exists
            const existingAllOption = Array.from(fileSelect.options).find(option => option.value === 'all');
            if (existingAllOption) return;
            
            // Add "All Lists" option at the top (first position)
            const allListsOption = document.createElement('option');
            allListsOption.value = 'all';
            allListsOption.textContent = 'All Lists';
            allListsOption.setAttribute('data-url', 'all');
            
            // Insert as the first option
            fileSelect.insertBefore(allListsOption, fileSelect.firstChild);
        }
        
        // Restore saved view state
        function restoreViewState() {
            // Restore the saved view mode (currentView is already loaded from localStorage)
            switchView(currentView);
        }
        
        // 3-dot menu functionality
        function toggleMenu() {
            const dropdown = document.getElementById('menu-dropdown');
            const button = document.getElementById('menu-toggle');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
                button.classList.remove('active');
            } else {
                dropdown.style.display = 'block';
                button.classList.add('active');
            }
        }
        
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            localStorage.setItem('isFullscreen', JSON.stringify(isFullscreen));
            
            const fullscreenText = document.getElementById('fullscreen-text');
            
            if (isFullscreen) {
                // Apply fullscreen to the body/container to include file selection
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                // Allow scrolling in fullscreen mode
                document.body.style.overflow = 'auto';
            } else {
                document.body.classList.remove('fullscreen-mode');
                fullscreenText.textContent = 'View Fullscreen';
                document.body.style.overflow = 'auto';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function toggleCondensed() {
            isCondensed = !isCondensed;
            localStorage.setItem('isCondensed', JSON.stringify(isCondensed));
            
            const card = document.getElementById('participants-table-card');
            const condensedText = document.getElementById('condensed-text');
            
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                card.classList.remove('condensed-mode');
                condensedText.textContent = 'Condense Layout';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function parseCSVRobust(csvText) {
            // Robust CSV parser that handles quoted fields with newlines, escaped quotes, and proper field separation
            // This prevents line returns within quoted field values from being treated as new rows
            const rows = [];
            let current = '';
            let inQuotes = false;
            let currentRow = [];
            let currentField = '';
            
            for (let i = 0; i < csvText.length; i++) {
                const char = csvText[i];
                const nextChar = csvText[i + 1];
                
                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        // Handle escaped quotes ("" inside quoted field)
                        currentField += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    currentRow.push(currentField.trim());
                    currentField = '';
                } else if ((char === '\n' || char === '\r\n') && !inQuotes) {
                    // End of row (only if not inside quotes)
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                    
                    // Skip \r if we're at \r\n
                    if (char === '\r' && nextChar === '\n') {
                        i++;
                    }
                } else if (char === '\r' && !inQuotes) {
                    // Handle standalone \r as row separator
                    currentRow.push(currentField.trim());
                    if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                        rows.push(currentRow);
                    }
                    currentRow = [];
                    currentField = '';
                } else {
                    // Regular character or newline inside quotes
                    currentField += char;
                }
            }
            
            // Handle last field and row
            if (currentField !== '' || currentRow.length > 0) {
                currentRow.push(currentField.trim());
                if (currentRow.length > 0 && currentRow.some(field => field !== '')) {
                    rows.push(currentRow);
                }
            }
            
            return rows;
        }

        function showAllFeeds() {
            // Load and display the meta-list Google Sheet with all feeds
            const masterSheetUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSxfv7lxikjrmro3EJYGE_134vm5HdDszZKt4uKswHhsNJ_-afSaG9RoA4oeNV656r4mTuG3wTu38pM/pub?output=csv';
            
            // Clear current data and show loading state
            const tableContainer = document.getElementById('participants-table-container');
            if (tableContainer) {
                tableContainer.innerHTML = '<div class="loading-state">Loading feeds list...</div>';
            }
            
            // Load the master sheet data
            fetch(masterSheetUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    // Check if we got HTML instead of CSV (redirect or error)
                    if (csvText.trim().toLowerCase().startsWith('<html')) {
                        throw new Error('Received HTML instead of CSV data');
                    }
                    
                    // Parse CSV data with robust parser that handles newlines in quoted fields
                    const rows = parseCSVRobust(csvText);
                    if (rows.length === 0) {
                        throw new Error('No data found in CSV');
                    }
                    
                    // First row contains headers
                    const headers = rows[0];
                    const feedsData = [];
                    
                    // Parse data rows
                    for (let i = 1; i < rows.length; i++) {
                        const values = rows[i];
                        if (values.length > 0) {
                            const feedEntry = {};
                            headers.forEach((header, index) => {
                                feedEntry[header] = values[index] || '';
                            });
                            feedsData.push(feedEntry);
                        }
                    }
                    
                    // Display the feeds data using the existing display system
                    currentData = feedsData;
                    // Reset team legend flag for new data
                    initialTeamLegendGenerated = false;
                    displayParticipantsTable(feedsData, 'All Available Feeds');
                    
                    // Update the page title
                    //document.title = 'All Available Feeds';
                    
                    // Show UI elements after successful feeds load
                    showListDisplayElements();
                    
                    // Update URL hash to list=all
                    updateListHashParam('all');
                    
                    // Close menu
                    document.getElementById('menu-dropdown').style.display = 'none';
                    document.getElementById('menu-toggle').classList.remove('active');
                })
                .catch(error => {
                    console.error('Error loading feeds list:', error);
                    if (tableContainer) {
                        tableContainer.innerHTML = '<div class="error-state">Error loading feeds list. Please try again.<br><small>Error: ' + error.message + '</small></div>';
                    }
                    
                    // Update URL hash to list=all even on error to maintain state
                    updateListHashParam('all');
                });
        }

        function toggleSelectList() {
            const fileSelectContainer = document.querySelector('#fileSelect').parentElement.parentElement;
            const selectListText = document.getElementById('select-list-text');
            
            if (!fileSelectContainer) {
                console.error('File selection container not found!');
                return;
            }
            
            // Use getComputedStyle to get the actual display value
            const computedStyle = window.getComputedStyle(fileSelectContainer);
            const isVisible = computedStyle.display !== 'none';
            
            if (isVisible) {
                fileSelectContainer.style.display = 'none';
                selectListText.textContent = 'Select List';
            } else {
                fileSelectContainer.style.display = 'block';
                selectListText.textContent = 'Hide List';
            }
            
            // Close menu
            document.getElementById('menu-dropdown').style.display = 'none';
            document.getElementById('menu-toggle').classList.remove('active');
        }
        
        function updateCondensedViewButtons() {
            // Update active state for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const activeBtn = document.getElementById(currentView + '-view-condensed');
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        function toggleFiltersDropdown() {
            const dropdown = document.getElementById('filters-dropdown');
            const isVisible = dropdown.style.display === 'block';
            
            if (isVisible) {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
            }
        }
        
        function restoreLayoutState() {
            const fullscreenText = document.getElementById('fullscreen-text');
            const condensedText = document.getElementById('condensed-text');
            
            // Restore fullscreen state
            if (isFullscreen) {
                document.body.classList.add('fullscreen-mode');
                fullscreenText.textContent = 'Exit Fullscreen';
                document.body.style.overflow = 'hidden';
            } else {
                fullscreenText.textContent = 'View Fullscreen';
            }
            
            // Restore condensed state
            const card = document.getElementById('participants-table-card');
            if (isCondensed) {
                card.classList.add('condensed-mode');
                condensedText.textContent = 'Expand Layout';
            } else {
                condensedText.textContent = 'Condense Layout';
            }
        }
        
        // Load README documentation and configuration
        document.addEventListener('DOMContentLoaded', async function() {
            
            // Restore saved view state
            restoreViewState();
            restoreLayoutState();
            
            // Initialize condensed view buttons
            updateCondensedViewButtons();
            
            // Note: loadGroupParticipants() is now called after file initialization
            
            // Check and update group participants panel visibility on page load
            updateGroupParticipantsVisibility();
            
            // Set initial header visibility based on current hash
            updateHeaderVisibility();
            
            // Listen for URL changes to update visibility
            window.addEventListener('hashchange', updateGroupParticipantsVisibility);
            
            // Listen for URL changes to handle list parameter changes
            window.addEventListener('hashchange', function() {
                const listParam = getURLHashParam('list');
                
                // Update UI for hash changes (header visibility and title)
                updateUIForHashChange();
                
                // Hide UI elements when list hash changes
                if (listParam && listParam !== fileSelect.value) {
                    hideListDisplayElements();
                    clearAllFilters();
                }
                
                // Update dropdown selection if it doesn't match current value
                if (listParam && listParam !== fileSelect.value) {
                    // Check if the option exists in the dropdown
                    const targetOption = Array.from(fileSelect.options).find(option => option.value === listParam);
                    if (targetOption) {
                        fileSelect.value = listParam;
                        selectedFile = targetOption.getAttribute('data-url') || listParam;
                        
                        // Load the corresponding data
                        if (listParam === 'all') {
                            showAllFeeds();
                        } else {
                            getMeetupParticipants();
                        }
                    }
                } else if (listParam === 'all' && fileSelect.value !== 'all') {
                    // Special case: URL has list=all but dropdown is not set to "All Lists"
                    hideListDisplayElements();
                    clearAllFilters();
                    fileSelect.value = 'all';
                    selectedFile = 'all';
                    showAllFeeds();
                }
                
                // Update menu visibility after any list changes
                updateMenuVisibility();
            });
            
            // Listen for URL changes to handle display mode changes
            window.addEventListener('hashchange', function() {
                const displayParam = getURLHashParam('display') || 'column'; // Default to column if absent
                if (['column', 'table', 'gallery'].includes(displayParam) && displayParam !== currentView) {
                    switchView(displayParam);
                }
            });
            
            // Listen for URL changes to handle group parameter changes
            window.addEventListener('hashchange', function() {
                // Skip group parameter processing if we're currently updating status
                if (isUpdatingStatus) {
                    console.log('🔄 Skipping group parameter processing during status update');
                    return;
                }
                
                const groupParam = getURLHashParam('group');
                const groupInput = document.getElementById('group');
                const currentValue = groupInput.value.split(',').map(n => n.trim()).filter(n => n).join(',');
                const newValue = groupParam ? groupParam.split(',').map(n => n.trim()).filter(n => n).join(',') : '';
                
                // Only update if the value has actually changed to avoid infinite loops
                if (currentValue !== newValue) {
                    console.log('🔗 Group parameter changed in URL hash:', groupParam);
                    if (groupParam) {
                        // Format the group string with proper spacing (replace commas with ", ")
                        const formattedGroupParam = groupParam.replace(/,/g, ', ');
                        groupInput.value = formattedGroupParam;
                        const hashNames = groupParam.split(',').map(name => name.trim()).filter(name => name);
                        groupParticipants = new Set(hashNames);
                        
                        // Validate names from hash parameter
                        validateGroupNames(hashNames);
                        
                        // Only activate group filter if user's cached preference allows it
                        // Don't override the user's last choice about showing all vs group only
                        updateGroupToggleUI();
                        if (showOnlyGroup) {
                            console.log('🔄 Group parameter from hash change, filter active per user preference');
                        } else {
                            console.log('🔄 Group parameter from hash change, but filter inactive per user preference');
                        }
                    } else if (currentValue !== '' && !groupParam) {
                        // Only clear the field if it currently has a value AND the hash parameter was explicitly removed
                        // (not just missing due to a status change)
                        console.log('🔗 Group hash parameter removed, asking user about clearing cached names');
                        
                        const shouldClearCached = confirm('Group hash parameter was removed.\nAlso clear the cached names?');
                        
                        if (shouldClearCached) {
                            // Clear everything including localStorage
                            groupInput.value = '';
                            groupParticipants = new Set();
                            localStorage.removeItem(getListStorageKey('groupParticipants'));
                            
                            // Deactivate group filter
                            showOnlyGroup = false;
                            localStorage.setItem(getListStorageKey('showOnlyGroup'), 'false');
                            updateGroupToggleUI();
                            hideGroupValidationMessage();
                            console.log('🔄 Cleared field and cached names - hash parameter removed');
                        } else {
                            // Keep cached names, restore from localStorage
                            const stored = localStorage.getItem(getListStorageKey('groupParticipants'));
                            if (stored && stored.trim()) {
                                const formattedStored = stored.replace(/,/g, ', ');
                                groupInput.value = formattedStored;
                                groupParticipants = new Set(stored.split(',').map(name => name.trim()).filter(name => name));
                                console.log('🔄 Restored cached names from localStorage');
                            } else {
                                groupInput.value = '';
                                groupParticipants = new Set();
                                showOnlyGroup = false;
                                localStorage.setItem(getListStorageKey('showOnlyGroup'), 'false');
                                updateGroupToggleUI();
                            }
                        }
                    } else {
                        console.log('🔗 No group hash parameter and field is empty, no action needed');
                    }
                    updateGroupCount();
                    updateGroupHighlighting();
                    saveGroupParticipants();
                    
                    // Apply filters since group filter state changed
                    applyAllFilters();
                }
            });
            
            // Note: Sort parameters are no longer in URL hash, only in localStorage
            
            // Listen for URL changes to handle team parameter changes
            window.addEventListener('hashchange', function() {
                const teamParam = getURLHashParam('team');
                if (teamParam !== currentTeamFilter) {
                    console.log('🔗 Team parameter changed in URL hash:', teamParam);
                    currentTeamFilter = teamParam;
                    
                    // Save to localStorage
                    if (currentTeamFilter) {
                        localStorage.setItem(getListStorageKey('participantsTeamFilter'), currentTeamFilter);
                    } else {
                        localStorage.removeItem(getListStorageKey('participantsTeamFilter'));
                    }
                    
                    // Apply filters
                    applyAllFilters();
                }
            });
            
            // Listen for URL changes to handle status parameter changes
            window.addEventListener('hashchange', function() {
                const statusParam = getURLHashParam('status');
                const newStatuses = statusParam ? statusParam.split(',') : ['All'];
                const currentStatusArray = Array.from(selectedStatuses);
                
                // Only update if the status selection has actually changed to avoid infinite loops
                if (JSON.stringify(currentStatusArray.sort()) !== JSON.stringify(newStatuses.sort())) {
                    console.log('🔗 Status parameter changed in URL hash:', statusParam);
                    selectedStatuses = new Set(newStatuses);
                    
                    // Save to localStorage
                    localStorage.setItem(getListStorageKey('participantsStatusFilter'), JSON.stringify(Array.from(selectedStatuses)));
                    
                    // Update UI
                    updateStatusButtonText();
                    generateStatusDropdown();
                    
                    // Apply filters
                    applyAllFilters();
                }
            });
            
            // Initialize file selection
            await initializeFileSelection();
            
            // Load group participants after file initialization is complete
            // This ensures clearAllFilters() doesn't wipe out localStorage values
            // Add small delay to ensure DOM is fully ready
            setTimeout(() => {
                console.log('🕐 Loading group participants after DOM is ready');
                loadGroupParticipants();
                
                // Load snapshot 1 if it exists
                loadSnapshotOnPageLoad();
            }, 100);
            
            // Check for list=all in URL hash to auto-load meta list
            const listParam = getURLHashParam('list');
            if (listParam === 'all') {
                showAllFeeds();
            } else {
                // Auto-load data if default option is selected
                const selectedOption = fileSelect.options[fileSelect.selectedIndex];
                if (selectedOption && selectedOption.getAttribute('data-url')) {
                    getMeetupParticipants();
                }
            }
            
            // Set initial menu visibility state
            updateMenuVisibility();
            
            // Add event listeners for 3-dot menu
            document.getElementById('menu-toggle').addEventListener('click', toggleMenu);
            
            document.getElementById('list-feeds-toggle').addEventListener('click', showAllFeeds);
            
            document.getElementById('fullscreen-toggle').addEventListener('click', toggleFullscreen);
            document.getElementById('condensed-toggle').addEventListener('click', toggleCondensed);
            document.getElementById('raw-data-toggle').addEventListener('click', toggleRawData);
            document.getElementById('export-csv-menu').addEventListener('click', exportCSVFromMenu);
            document.getElementById('full-url-toggle').addEventListener('click', generateFullURL);
            document.getElementById('snapshots-toggle').addEventListener('click', toggleSnapshots);
            
            // Snapshots event listeners
            document.getElementById('close-snapshots').addEventListener('click', () => {
                document.getElementById('snapshots-control').style.display = 'none';
            });
            document.getElementById('add-snapshot-btn').addEventListener('click', addNewSnapshot);
            document.getElementById('new-snapshot-name').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    addNewSnapshot();
                }
            });
            
            // Add event listeners for condensed view controls
            document.getElementById('filters-toggle').addEventListener('click', toggleFiltersDropdown);
            
            // Add event listeners for condensed view buttons
            document.querySelectorAll('.view-buttons-condensed .condensed-icon-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const view = this.dataset.view;
                    switchView(view);
                });
            });
            
            // Add event listeners for condensed filters dropdown
            document.getElementById('condensed-sort-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleSortDropdown();
            });
            
            document.getElementById('condensed-status-toggle').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('filters-dropdown').style.display = 'none';
                toggleStatusDropdown();
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', function(e) {
                const menuDropdown = document.getElementById('menu-dropdown');
                const menuToggle = document.getElementById('menu-toggle');
                const filtersDropdown = document.getElementById('filters-dropdown');
                const filtersToggle = document.getElementById('filters-toggle');
                
                if (!menuDropdown.contains(e.target) && !menuToggle.contains(e.target)) {
                    menuDropdown.style.display = 'none';
                    menuToggle.classList.remove('active');
                }
                
                if (!filtersDropdown.contains(e.target) && !filtersToggle.contains(e.target)) {
                    filtersDropdown.style.display = 'none';
                }
            });
        });
        
        // Pagination functions
        function updatePaginationControls() {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const paginationControls = document.querySelector('.pagination-controls');
            const prevBtn = document.getElementById('prev-page');
            const nextBtn = document.getElementById('next-page');
            
            if (totalRecords > recordsPerPage) {
                paginationControls.style.display = 'flex';
                prevBtn.disabled = currentPage <= 1;
                nextBtn.disabled = currentPage >= totalPages;
            } else {
                paginationControls.style.display = 'none';
            }
        }
        
        function updateResultsCount(filteredData) {
            const resultsCount = document.getElementById('results-count');
            if (!resultsCount) return;
            
            totalRecords = filteredData.length;
            const originalTotal = allParticipantsData ? allParticipantsData.length : totalRecords;
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            const startRecord = Math.min((currentPage - 1) * recordsPerPage + 1, totalRecords);
            const endRecord = Math.min(currentPage * recordsPerPage, totalRecords);
            
            if (totalRecords === 0) {
                resultsCount.textContent = `0 results in ${originalTotal} total`;
            } else if (totalRecords <= recordsPerPage) {
                if (totalRecords === originalTotal) {
                    // No filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''}`;
                } else {
                    // Filtering applied
                    resultsCount.textContent = `${totalRecords} result${totalRecords !== 1 ? 's' : ''} in ${originalTotal} total`;
                }
            } else {
                resultsCount.textContent = `${startRecord} to ${endRecord} results in ${originalTotal} total`;
            }
            
            updatePaginationControls();
        }
        
        function paginateData(data) {
            const startIndex = (currentPage - 1) * recordsPerPage;
            const endIndex = Math.min(startIndex + recordsPerPage, data.length);
            return data.slice(startIndex, endIndex);
        }
        
        function goToPage(page) {
            const totalPages = Math.ceil(totalRecords / recordsPerPage);
            if (page >= 1 && page <= totalPages) {
                currentPage = page;
                applyAllFilters(); // Re-apply filters and refresh display
            }
        }
        
        // Add pagination event listeners
        document.getElementById('prev-page').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });
        
        document.getElementById('next-page').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });
    </script>

</body>
</html>
